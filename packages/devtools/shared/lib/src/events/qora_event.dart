import 'dart:math';

/// Base contract for every event exchanged between the Qora runtime bridge
/// and the DevTools UI.
///
/// Events flow in one direction only: **App → DevTools** (push via
/// `developer.postEvent`). They are never mutated after creation; they are
/// plain immutable data objects whose JSON representation is the sole
/// transport artefact.
///
/// ## Event kind taxonomy
///
/// Kinds follow the `<domain>.<action>` convention:
///
/// | Domain     | Actions                                         |
/// |------------|-------------------------------------------------|
/// | `query`    | `added`, `updated`, `removed`, `fetched`, `invalidated` |
/// | `mutation` | `started`, `updated`, `settled`                |
/// | `optimistic` | `applied`, `rolled_back`                   |
/// | `cache`    | `cleared`                                       |
///
/// The [EventCodec] routes incoming payloads to the correct subclass based
/// on the kind prefix (`query.`, `mutation.`). Unrecognised kinds fall back
/// to [GenericQoraEvent].
///
/// ## Adding a new event type
///
/// 1. Create `packages/devtools/shared/lib/src/events/my_event.dart`
///    extending [QoraEvent].
/// 2. Add a `fromJson` factory and override [toJson].
/// 3. Register the kind prefix in [EventCodec.decode].
/// 4. Export the new file from `qora_devtools_shared.dart`.
/// 5. Add the hook to [QoraTracker] and its implementations.
///
/// No existing files need to change until step 3; the rest of the code is
/// forward-compatible thanks to [GenericQoraEvent].
///
/// ## JSON schema (minimum required fields)
///
/// ```json
/// {
///   "eventId":    "evt_1725012345_a3f",
///   "kind":       "query.fetched",
///   "timestampMs": 1725012345678
/// }
/// ```
abstract class QoraEvent {
  /// Unique event identifier.
  ///
  /// Generated by [generateId]. Used by the UI to deduplicate events that
  /// arrive out of order or are replayed on reconnection.
  final String eventId;

  /// Event kind string following the `<domain>.<action>` convention.
  ///
  /// See the kind taxonomy in the class-level documentation for valid values.
  /// The [EventCodec] uses this field to route deserialization.
  final String kind;

  /// Unix epoch in milliseconds at the moment the event was created.
  ///
  /// Recorded on the **app side** — do not rely on this for UI clock
  /// synchronisation; use it for ordering and relative durations only.
  final int timestampMs;

  /// Creates a protocol event.
  const QoraEvent({
    required this.eventId,
    required this.kind,
    required this.timestampMs,
  });

  /// Converts the event to a JSON-safe map suitable for `developer.postEvent`.
  ///
  /// All subclasses must include `eventId`, `kind`, and `timestampMs` in the
  /// returned map so that [EventCodec.decode] can reconstruct them.
  Map<String, Object?> toJson();

  /// Generates a compact unique identifier suitable for debug tooling.
  ///
  /// The identifier is **not** cryptographically secure — it is intended for
  /// short-lived deduplication in DevTools sessions only.
  ///
  /// Format: `evt_<microsecondsSinceEpoch>_<randomHex>`
  static String generateId() {
    final random = Random().nextInt(0x7fffffff).toRadixString(16);
    return 'evt_${DateTime.now().microsecondsSinceEpoch}_$random';
  }
}

/// Fallback event used when no typed implementation matches the received kind.
///
/// [GenericQoraEvent] preserves **forward compatibility**: when an older
/// DevTools UI receives an event kind introduced in a newer runtime version,
/// it can still display the raw payload in the timeline instead of crashing.
///
/// ## Scaling note
///
/// If the DevTools timeline accumulates many [GenericQoraEvent] entries in
/// production, it is a signal that the `shared` package version is out of
/// sync between the runtime and the UI. Surface this discrepancy in the
/// DevTools header to guide the developer.
final class GenericQoraEvent extends QoraEvent {
  /// Creates a generic event with arbitrary [payload].
  ///
  /// [payload] typically mirrors the full JSON map received from the runtime,
  /// providing raw access to unrecognised fields.
  GenericQoraEvent({
    required super.eventId,
    required super.kind,
    required super.timestampMs,
    Map<String, Object?>? payload,
  }) : payload = payload ?? const <String, Object?>{};

  /// Additional untyped fields preserved from the original JSON payload.
  final Map<String, Object?> payload;

  /// Builds a generic event from a raw JSON map, tolerating missing fields.
  factory GenericQoraEvent.fromJson(Map<String, Object?> json) {
    return GenericQoraEvent(
      eventId: (json['eventId'] as String?) ?? QoraEvent.generateId(),
      kind: (json['kind'] as String?) ?? 'unknown',
      timestampMs: (json['timestampMs'] as int?) ?? DateTime.now().millisecondsSinceEpoch,
      payload: Map<String, Object?>.from(json),
    );
  }

  @override
  Map<String, Object?> toJson() => <String, Object?>{
        ...payload,
        'eventId': eventId,
        'kind': kind,
        'timestampMs': timestampMs,
      };
}
