---
title: QoraMutationBuilder
description: The widget that manages a MutationController lifecycle and rebuilds your UI on every mutation state transition.
seo:
  title: QoraMutationBuilder — Flutter Qora
  description: Bind write operations to Flutter UI with QoraMutationBuilder. Automatic controller lifecycle, optimistic updates, and DevTools wiring included.
---

`QoraMutationBuilder<TData, TVariables, TContext>` creates a `MutationController` on mount, disposes it on unmount, and rebuilds whenever the mutation state changes. The `builder` callback receives the current `MutationState` and a `mutate(variables)` callback to trigger the write from the UI.

:::tip
`QoraMutationBuilder` does not require a `QoraScope` ancestor. It wires itself to the client automatically when one is present, and falls back to standalone mode gracefully when one is not.
:::

---

## Basic Usage

```dart [create_post_screen.dart]
QoraMutationBuilder<Post, String, void>(
  mutationFn: (title) => api.createPost(title),
  builder: (context, state, mutate) {
    return ElevatedButton(
      onPressed: state.isPending ? null : () => mutate('New Post'),
      child: state.isPending
          ? const CircularProgressIndicator()
          : const Text('Create'),
    );
  },
)
```

The button is disabled while the mutation is running. Pass `null` to `onPressed` — Flutter disables the button automatically.

---

## State-Driven UI

Pattern-match directly on the sealed `MutationState` for exhaustive UI coverage:

```dart [create_post_screen.dart]
QoraMutationBuilder<Post, String, void>(
  mutationFn: (title) => api.createPost(title),
  builder: (context, state, mutate) {
    return switch (state) {
      MutationIdle()                => SubmitButton(onTap: () => mutate('Post')),
      MutationPending()             => const CircularProgressIndicator(),
      MutationSuccess(:final data)  => SuccessBanner('Created: ${data.title}'),
      MutationFailure(:final error) => Column(children: [
          ErrorBanner(error),
          TextButton(
            onPressed: () => mutate('Post'), // Retry
            child: const Text('Try again'),
          ),
        ]),
    };
  },
)
```

---

## Props

| Prop        | Type                                               | Default    | Description                                                                             |
| ----------- | -------------------------------------------------- | ---------- | --------------------------------------------------------------------------------------- |
| `mutationFn`   | `Future<TData> Function(TVariables)`               | required   | The async function performing the write. Named `mutationFn` to mirror `queryFn`.           |
| `builder`   | `Widget Function(context, MutationState, mutate)`  | required   | Builds the widget tree from the current state.                                          |
| `options`   | `MutationOptions<TData, TVariables, TContext>?`    | `null`     | Lifecycle hooks (`onMutate`, `onSuccess`, `onError`, `onSettled`) and retry config.     |
| `metadata`  | `Map<String, Object?>?`                            | `null`     | Custom key-value pairs forwarded to every `MutationEvent`. Useful for DevTools labels.  |

---

## The `builder` Callback

```dart
Widget Function(
  BuildContext context,
  MutationState<TData, TVariables> state,
  Future<TData?> Function(TVariables variables) mutate,
)
```

- **`state`** — the current sealed `MutationState`. Pattern-match or use `.isPending`, `.isSuccess`, `.isError` helpers.
- **`mutate(variables)`** — triggers the mutation. Returns `TData` on success or `null` on failure. Errors never propagate to the caller; they appear as `MutationFailure` state instead.

---

## Lifecycle Hooks

Use `options` to perform side-effects around the mutation:

```dart [settings_screen.dart]
QoraMutationBuilder<void, UserUpdate, void>(
  mutationFn: (update) => api.updateUser(update),
  options: MutationOptions(
    onSuccess: (_, update, __) async {
      context.qora.invalidate(['users', currentUserId]);
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Settings saved')),
      );
    },
    onError: (error, _, __) async {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error: $error')),
      );
    },
  ),
  builder: (context, state, mutate) {
    return SaveButton(
      isLoading: state.isPending,
      onTap: () => mutate(formData),
    );
  },
)
```

:::warning
Capturing `context` inside `onSuccess`/`onError` is safe as long as the widget is still mounted. Prefer using `ScaffoldMessenger.of(context)` — it is resilient to widget tree changes. Avoid `Navigator.of(context)` in async callbacks without a mounted check.
:::

---

## Optimistic Updates

Combine `onMutate` (optimistic write) and `onError` (rollback) to give instant feedback while the server confirms the change:

```dart [todo_list_screen.dart]
QoraMutationBuilder<void, Todo, List<Todo>?>(
  // TContext = List<Todo>? — the snapshot for rollback
  mutationFn: (todo) => api.addTodo(todo),
  options: MutationOptions(
    onMutate: (todo) async {
      // 1️⃣ Snapshot current list
      final prev = context.qora.getQueryData<List<Todo>>(['todos']);

      // 2️⃣ Apply optimistically — UI updates before the network call
      context.qora.setQueryData<List<Todo>>(
        ['todos'],
        [...?prev, todo.copyWith(isOptimistic: true)],
      );

      return prev; // Returned as TContext
    },
    onError: (_, __, prev) async {
      // 3️⃣ Rollback on failure
      context.qora.restoreQueryData(['todos'], prev);
    },
    onSuccess: (_, __, ___) async {
      // 4️⃣ Pull confirmed data from server
      context.qora.invalidate(['todos']);
    },
  ),
  builder: (context, state, mutate) {
    return AddTodoButton(
      isLoading: state.isPending,
      onTap: () => mutate(newTodo),
    );
  },
)
```

`context.qora` is the shorthand for `QoraScope.of(context)` — available when the widget is inside a `QoraScope`.

---

## Reset

After displaying a success or failure result, call `reset()` to return to `MutationIdle` and allow the user to trigger another mutation.

Because `QoraMutationBuilder` owns the controller internally, you can drive reset through external widget state:

```dart [create_post_screen.dart]
QoraMutationBuilder<Post, String, void>(
  mutationFn: (title) => api.createPost(title),
  builder: (context, state, mutate) {
    if (state is MutationSuccess<Post, String>) {
      return Column(children: [
        Text('Created: ${state.data.title}'),
        TextButton(
          // Rebuilds with a fresh idle state on next frame
          onPressed: () => setState(() {}),
          child: const Text('Create another'),
        ),
      ]);
    }
    return SubmitButton(
      onTap: state.isPending ? null : () => mutate('My Post'),
    );
  },
)
```

:::tip
If you need programmatic `reset()` or `mutate()` access outside the builder, consider using `MutationController` directly and subscribing to its `stream` in a `StatefulWidget`.
:::

---

## DevTools Labelling with `metadata`

Attach domain context to every `MutationEvent` for easier DevTools filtering:

```dart [auth_screen.dart]
QoraMutationBuilder<User, LoginCredentials, void>(
  mutationFn: authApi.login,
  metadata: {'category': 'auth', 'screen': 'login'},
  builder: (context, state, mutate) { ... },
)
```

All events emitted by this controller will include `metadata: {'category': 'auth', 'screen': 'login'}`, visible in `client.mutationEvents` and `client.activeMutations`.

---

## Standalone Mode

`QoraMutationBuilder` is safe to use anywhere in the widget tree — even without a `QoraScope` ancestor. In that case, `tracker` is `null` and the controller operates in standalone mode with no global DevTools wiring:

```dart [onboarding_screen.dart]
// No QoraScope required
QoraMutationBuilder<void, OnboardingData, void>(
  mutationFn: onboardingApi.submit,
  builder: (context, state, mutate) { ... },
)
```

---

## Controller Lifecycle

The internal `MutationController` is:

- **Created** on widget mount (`initState`)
- **Recreated** when `mutationFn`, `options`, or `metadata` identity changes (`didUpdateWidget`)
- **Disposed** on widget unmount (`dispose`)

When the controller is recreated, the mutation state resets to `MutationIdle`.

---

## Next Steps

- [Mutations Guide](../guides/mutations.md) — Full conceptual guide with all patterns
- [Optimistic Updates](../guides/optimistic-updates.md) — Deep dive into rollback
- [Mutation API Reference](../api-reference/qora-mutation.md) — Full API documentation
