---
title: Hooks (flutter_hooks)
description: >
  Use useQuery, useMutation and useInfiniteQuery with flutter_hooks
  for a more concise, composable API.
---

If your project uses [flutter_hooks](https://pub.dev/packages/flutter_hooks),
`qora_hooks` provides a hooks-based API that reads more naturally and
composes better in complex screens.

## Installation

::code-group

```yaml [pubspec.yaml]
# You don't need to add `qora` — it's included transitively.
dependencies:
  flutter_hooks: ^0.21.0
  qora_hooks: ^1.0.0
```

::

## useQuery

Fetches data and rebuilds the widget when the state changes.
Equivalent to `QoraBuilder` but without the nested `builder` callback.

```dart
class UserScreen extends HookWidget {
  final String userId;
  const UserScreen({super.key, required this.userId});

  @override
  Widget build(BuildContext context) {
    final state = useQuery<User>(
      key: ['users', userId],
      fetcher: () => Api.getUser(userId),
      options: const QoraOptions(staleTime: Duration(minutes: 5)),
    );

    return switch (state) {
      QueryInitial()                    => const SizedBox.shrink(),
      QueryLoading(:final previousData) => previousData != null
          ? UserCard(previousData)
          : const CircularProgressIndicator(),
      QuerySuccess(:final data)         => UserCard(data),
      QueryFailure(:final error)        => ErrorView(error),
    };
  }
}
```

### Parameters

| Parameter | Type | Description |
|---|---|---|
| `key` | `List<Object?>` | Unique identifier for this query. Changing it triggers a new fetch. |
| `fetcher` | `Future<T> Function()` | The async function that returns the data. |
| `options` | `QoraOptions` | `staleTime`, `cacheTime`, `retry`, etc. |

### Return value

Returns a `QueryState<T>` — a sealed class with four variants:
`QueryInitial`, `QueryLoading`, `QuerySuccess`, `QueryFailure`.

---

## useMutation

Triggers a mutation and tracks its state.

```dart
class EditProfileScreen extends HookWidget {
  @override
  Widget build(BuildContext context) {
    final client = useQueryClient();

    final mutation = useMutation<User, UpdateUserInput>(
      mutationFn: (input) => Api.updateUser(input),
      onSuccess: (user, _) {
        client.invalidateQuery(['users', user.id]);
      },
    );

    return ElevatedButton(
      onPressed: mutation.isPending
          ? null
          : () => mutation.mutate(UpdateUserInput(name: 'Alice')),
      child: mutation.isPending
          ? const CircularProgressIndicator()
          : const Text('Save'),
    );
  }
}
```

### Parameters

| Parameter | Type | Description |
|---|---|---|
| `mutationFn` | `Future<TData> Function(TVariables)` | The async function that performs the mutation. |
| `onSuccess` | `void Function(TData, TVariables)?` | Called when the mutation succeeds. |
| `onError` | `void Function(Object, TVariables)?` | Called when the mutation fails. |
| `onMutate` | `void Function(TVariables)?` | Called before `mutationFn` — use for optimistic updates. |

### Return value

Returns a `MutationHandle<TData, TVariables>`:

| Property | Type | Description |
|---|---|---|
| `mutate` | `void Function(TVariables)` | Triggers the mutation. Errors are caught internally. |
| `mutateAsync` | `Future<TData> Function(TVariables)` | Triggers the mutation. Errors are propagated. |
| `reset` | `void Function()` | Resets the state to idle. |
| `isIdle` | `bool` | |
| `isPending` | `bool` | |
| `isSuccess` | `bool` | |
| `isError` | `bool` | |
| `data` | `TData?` | Available when `isSuccess`. |
| `error` | `Object?` | Available when `isError`. |

---

## useQueryClient

Returns the nearest `QueryClient` from the widget tree.

```dart
final client = useQueryClient();
client.invalidateQuery(['posts']);
```

The widget must be wrapped in a `QoraScope` for this to work.

---

## useInfiniteQuery

Manages paginated data — accumulates pages and exposes a
`fetchNextPage` function.

```dart
class PostsScreen extends HookWidget {
  @override
  Widget build(BuildContext context) {
    final query = useInfiniteQuery<PostsPage, String?>(
      key: const ['posts'],
      fetcher: (cursor) => Api.getPosts(cursor: cursor),
      getNextPageParam: (page) => page.nextCursor,
      initialPageParam: null,
    );

    final posts = query.pages.expand((p) => p.posts).toList();

    return ListView.builder(
      itemCount: posts.length + (query.hasNextPage ? 1 : 0),
      itemBuilder: (context, i) {
        if (i == posts.length) {
          if (!query.isFetchingNextPage) query.fetchNextPage();
          return const Center(child: CircularProgressIndicator());
        }
        return PostTile(posts[i]);
      },
    );
  }
}
```

### Parameters

| Parameter | Type | Description |
|---|---|---|
| `key` | `List<Object?>` | Query key. |
| `fetcher` | `Future<TData> Function(TPageParam)` | Called with the page param for each page. |
| `getNextPageParam` | `TPageParam? Function(TData lastPage)` | Return `null` to signal there are no more pages. |
| `initialPageParam` | `TPageParam` | The param passed to `fetcher` for the first page. |

### Return value

Returns an `InfiniteQueryHandle<TData, TPageParam>`:

| Property | Type | Description |
|---|---|---|
| `pages` | `List<TData>` | All fetched pages in order. |
| `isLoading` | `bool` | True while the first page is loading. |
| `isFetchingNextPage` | `bool` | True while a subsequent page is loading. |
| `hasNextPage` | `bool` | False when `getNextPageParam` returns `null`. |
| `fetchNextPage` | `Future<void> Function()` | Loads the next page. No-op if already loading. |
| `error` | `Object?` | Last error, if any. |

---

## Combining hooks

Hooks compose naturally. Here is a screen that fetches a user,
updates their profile, and shows an inline error — all in one widget,
no `setState`, no `StreamBuilder`.

```dart
class ProfileScreen extends HookWidget {
  final String userId;
  const ProfileScreen({super.key, required this.userId});

  @override
  Widget build(BuildContext context) {
    final client   = useQueryClient();
    final userQuery = useQuery<User>(
      key: ['users', userId],
      fetcher: () => Api.getUser(userId),
    );
    final updateMutation = useMutation<User, UpdateUserInput>(
      mutationFn: Api.updateUser,
      onSuccess: (user, _) => client.invalidateQuery(['users', userId]),
    );

    return switch (userQuery) {
      QueryLoading() => const CircularProgressIndicator(),
      QueryFailure(:final error) => ErrorView(error),
      QuerySuccess(:final data) => ProfileForm(
        user: data,
        isSaving: updateMutation.isPending,
        saveError: updateMutation.error,
        onSave: (input) => updateMutation.mutate(input),
      ),
      _ => const SizedBox.shrink(),
    };
  }
}
```

---

::callout{type="info"}
`qora_hooks` requires your widget to extend `HookWidget` (or use
`HookConsumerWidget` if you are combining with Riverpod). Standard
`StatelessWidget` and `StatefulWidget` are not supported — use
`QoraBuilder` and `MutationBuilder` instead.
::
