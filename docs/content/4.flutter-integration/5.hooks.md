---
title: Hooks (flutter_hooks)
description: >
  Use useQuery, useMutation and useInfiniteQuery with flutter_hooks
  for a more concise, composable API.
---

If your project uses [flutter_hooks](https://pub.dev/packages/flutter_hooks),
`qora_hooks` provides a hooks-based API that reads more naturally and
composes better in complex screens.

## Installation

::code-group

```yaml [pubspec.yaml]
# You don't need to add `qora` — it's included transitively.
dependencies:
  flutter_hooks: ^0.21.0
  qora_hooks: ^0.1.0
```

::

## useQuery

Fetches data and rebuilds the widget when the state changes.
Equivalent to `QoraBuilder` but without the nested `builder` callback.

```dart
class UserScreen extends HookWidget {
  final String userId;
  const UserScreen({super.key, required this.userId});

  @override
  Widget build(BuildContext context) {
    final state = useQuery<User>(
      key: ['users', userId],
      fetcher: () => Api.getUser(userId),
      options: const QoraOptions(staleTime: Duration(minutes: 5)),
    );

    return switch (state) {
      Initial()                    => const SizedBox.shrink(),
      Loading(:final previousData) => previousData != null
          ? UserCard(previousData)
          : const CircularProgressIndicator(),
      Success(:final data)         => UserCard(data),
      Failure(:final error)        => ErrorView(error),
    };
  }
}
```

### useQuery parameters

| Parameter | Type                  | Description                               |
| --------- | --------------------- | ------------------------------------------ |
| `key`     | `List<Object?>`       | Query identifier. Changes trigger refetch. |
| `fetcher` | `Future<T> Function()` | Async function returning the data.        |
| `options` | `QoraOptions?`        | Per-query caching/retry configuration.    |

### useQuery return value

Returns a `QoraState<T>` — a sealed class with four variants:
`Initial`, `Loading`, `Success`, `Failure`.

---

## useMutation

Triggers a mutation and tracks its state.

```dart
class EditProfileScreen extends HookWidget {
  @override
  Widget build(BuildContext context) {
    final mutation = useMutation<User, UpdateUserInput>(
      mutator: (input) => Api.updateUser(input),
      options: MutationOptions(
        onSuccess: (user, _, __) async {
          QoraScope.of(context).invalidate(['users', user.id]);
        },
      ),
    );

    return ElevatedButton(
      onPressed: mutation.isPending
          ? null
          : () => mutation.mutate(UpdateUserInput(name: 'Alice')),
      child: mutation.isPending
          ? const CircularProgressIndicator()
          : const Text('Save'),
    );
  }
}
```

### useMutation parameters

| Parameter | Type                                 | Description                             |
| --------- | ------------------------------------ | --------------------------------------- |
| `mutator` | `Future<TData> Function(TVariables)` | Async function performing the mutation. |
| `options` | `MutationOptions?`                   | Lifecycle callbacks and retry settings. |

### useMutation return value

Returns a `MutationHandle<TData, TVariables>`:

| Property      | Type                                  | Description                              |
| ------------- | ------------------------------------- | ---------------------------------------- |
| `mutate`      | `void Function(TVariables)`           | Fire-and-forget; errors go to state.     |
| `mutateAsync` | `Future<TData?> Function(TVariables)` | Returns the result or `null` on failure. |
| `reset`       | `void Function()`                     | Resets state to `MutationIdle`.          |
| `isIdle`      | `bool`                                | `true` when no mutation has run yet.     |
| `isPending`   | `bool`                                | `true` while the mutation is running.    |
| `isSuccess`   | `bool`                                | `true` after successful completion.      |
| `isError`     | `bool`                                | `true` after a failure.                  |
| `data`        | `TData?`                              | Available when `isSuccess`.              |
| `error`       | `Object?`                             | Available when `isError`.                |

---

## useQueryClient

Returns the nearest `QoraClient` from the widget tree.

```dart
final client = useQueryClient();
client.invalidate(['posts']);
```

The widget must be wrapped in a `QoraScope` for this to work.

---

## useInfiniteQuery

Manages paginated data — accumulates pages and exposes a
`fetchNextPage` function.

```dart
class PostsScreen extends HookWidget {
  @override
  Widget build(BuildContext context) {
    final query = useInfiniteQuery<PostsPage, String?>(
      key: const ['posts'],
      fetcher: (cursor) => Api.getPosts(cursor: cursor),
      getNextPageParam: (page) => page.nextCursor,
      initialPageParam: null,
    );

    final posts = query.pages.expand((p) => p.posts).toList();

    return ListView.builder(
      itemCount: posts.length + (query.hasNextPage ? 1 : 0),
      itemBuilder: (context, i) {
        if (i == posts.length) {
          if (!query.isFetchingNextPage) query.fetchNextPage();
          return const Center(child: CircularProgressIndicator());
        }
        return PostTile(posts[i]);
      },
    );
  }
}
```

### useInfiniteQuery parameters

| Parameter          | Type                                 | Description                               |
| ------------------ | ------------------------------------ | ------------------------------------------ |
| `key`              | `List<Object?>`                      | Query identifier. Changes trigger refetch. |
| `fetcher`          | `Future<TData> Function(TPageParam)` | Called with page param for each page.      |
| `getNextPageParam` | `TPageParam? Function(TData)`        | Returns `null` to signal last page.        |
| `initialPageParam` | `TPageParam`                         | First page param passed to `fetcher`.      |

### useInfiniteQuery return value

Returns an `InfiniteQueryHandle<TData, TPageParam>`:

| Property             | Type                      | Description                               |
| -------------------- | ------------------------- | ----------------------------------------- |
| `pages`              | `List<TData>`             | All fetched pages in order.               |
| `isLoading`          | `bool`                    | `true` while the first page is loading.   |
| `isFetchingNextPage` | `bool`                    | `true` while a next page is loading.      |
| `hasNextPage`        | `bool`                    | `false` when no more pages are available. |
| `fetchNextPage`      | `Future<void> Function()` | Loads next page. No-op if busy.           |
| `error`              | `Object?`                 | Last error, or `null`.                    |

---

## Combining hooks

Hooks compose naturally. Here is a screen that fetches a user,
updates their profile, and shows an inline error — all in one widget,
no `setState`, no `StreamBuilder`.

```dart
class ProfileScreen extends HookWidget {
  final String userId;
  const ProfileScreen({super.key, required this.userId});

  @override
  Widget build(BuildContext context) {
    final client = useQueryClient();
    final userQuery = useQuery<User>(
      key: ['users', userId],
      fetcher: () => Api.getUser(userId),
    );
    final updateMutation = useMutation<User, UpdateUserInput>(
      mutator: Api.updateUser,
      options: MutationOptions(
        onSuccess: (user, _, __) async =>
            client.invalidate(['users', userId]),
      ),
    );

    return switch (userQuery) {
      Loading()             => const CircularProgressIndicator(),
      Failure(:final error) => ErrorView(error),
      Success(:final data)  => ProfileForm(
        user: data,
        isSaving: updateMutation.isPending,
        saveError: updateMutation.error,
        onSave: (input) => updateMutation.mutate(input),
      ),
      _ => const SizedBox.shrink(),
    };
  }
}
```

---

::callout{type="info"}
`qora_hooks` requires your widget to extend `HookWidget` (or use
`HookConsumerWidget` if you are combining with Riverpod). Standard
`StatelessWidget` and `StatefulWidget` are not supported — use
`QoraBuilder` and `QoraMutationBuilder` instead.
::
