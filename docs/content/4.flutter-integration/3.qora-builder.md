---
title: QoraBuilder
description: The widget that fetches data, subscribes to state changes, and rebuilds your UI on every state transition.
---

`QoraBuilder<T>` is the primary way to bind server data to Flutter UI. It handles the full query lifecycle — fetching, caching, reactivity, background revalidation — with a single widget declaration.

---

## Basic Usage

```dart [user_list_screen.dart]
QoraBuilder<List<User>>(
  queryKey: ['users'],
  queryFn: () => api.getUsers(),
  builder: (context, state) {
    return switch (state) {
      Initial()                                   => const SizedBox.shrink(),
      Loading(:final previousData)                => previousData != null
          ? Stack(children: [UserList(previousData), const LinearProgressIndicator()])
          : const CircularProgressIndicator(),
      Success(:final data)                        => UserList(data),
      Failure(:final error, :final previousData)  => previousData != null
          ? Column(children: [UserList(previousData), ErrorBanner(error)])
          : ErrorScreen(error),
    };
  },
)
```

The builder is called on every state transition. Exhaustive pattern-matching over the sealed class is the idiomatic approach.

---

## How It Works

On mount, `QoraBuilder`:

1. **Subscribes** to `client.watchState<T>(queryKey)` — an observe-only stream that emits every state update for this key (including updates triggered by other widgets or background services).
2. **Fetches** via `client.fetchQuery(...)` if `enabled` is `true`. The client handles deduplication, caching, and stale-while-revalidate automatically.

When the query is **externally invalidated** (via `client.invalidate()`, a lifecycle resume, or a reconnect event), the state transitions to `Loading(previousData: data)`. `QoraBuilder` detects this pattern in the stream and dispatches a fresh `fetchQuery`. The client's deduplication ensures only one network request fires even if multiple widgets are subscribed to the same key.

---

## Props

| Prop               | Type                                          | Default  | Description                                                                              |
| ------------------ | --------------------------------------------- | -------- | ---------------------------------------------------------------------------------------- |
| `queryKey`         | `Object` (`List` or `QoraKey`)                | required | Cache key. Changing it triggers re-subscription and a fresh fetch.                       |
| `queryFn`          | `Future<T> Function()`                        | required | Async function that returns the data. Must throw on failure.                             |
| `builder`          | `Widget Function(BuildContext, QoraState<T>)` | required | Builds the widget tree from the current state.                                           |
| `options`          | `QoraOptions?`                                | `null`   | Per-query config merged on top of `QoraClientConfig.defaultOptions`.                     |
| `enabled`          | `bool`                                        | `true`   | When `false`, no fetch is triggered. The widget still observes the current cached state. |
| `keepPreviousData` | `bool`                                        | `false`  | Augments `Loading`/`Failure` states with the last known `Success` data from this widget. |
| `client`           | `QoraClient?`                                 | `null`   | Override the client from `QoraScope`. Useful for testing or nested scopes.               |

---

## Patterns

### Handling all four states

Use `.when()` for exhaustive matching or `.maybeWhen()` when you only care about specific states:

```dart [user_screen.dart]
QoraBuilder<User>(
  queryKey: ['users', userId],
  queryFn: () => api.getUser(userId),
  builder: (context, state) {
    return state.when(
      onInitial: () => const SizedBox.shrink(),
      onLoading: (previousData) => previousData != null
          ? UserCard(user: previousData, isRefreshing: true)
          : const CircularProgressIndicator(),
      onSuccess: (user, updatedAt) => UserCard(user: user),
      onError: (error, stackTrace, previousData) => ErrorScreen(
        message: error.toString(),
        onRetry: () => context.qora.invalidate(['users', userId]),
      ),
    );
  },
)
```

---

### Conditional queries (`enabled`)

Prevent fetching until a dependency is available:

```dart [profile_screen.dart]
QoraBuilder<Profile>(
  queryKey: ['profiles', userId],
  queryFn: () => api.getProfile(userId!),
  enabled: userId != null,   // No fetch until userId is resolved
  builder: (context, state) { ... },
)
```

When `enabled` flips from `false` to `true` (e.g. via `setState`), a fetch is triggered automatically.

---

### Flicker-free pagination (`keepPreviousData`)

When the query key changes (e.g. page number increments), the new key starts in `Initial` state — causing a jarring full-screen spinner. `keepPreviousData` prevents this by carrying the last successful data forward into the new key's loading phase:

```dart [paginated_posts_screen.dart]
QoraBuilder<List<Post>>(
  queryKey: ['posts', currentPage],
  queryFn: () => api.getPosts(page: currentPage),
  keepPreviousData: true,
  builder: (context, state) {
    // dataOrNull returns data from Success, Loading.previousData, or Failure.previousData
    final posts = state.dataOrNull ?? [];
    return Stack(
      children: [
        PostList(posts: posts),
        if (state.isLoading) const LinearProgressIndicator(),
      ],
    );
  },
)
```

:::tip
`keepPreviousData` only fills in the gap: if the client already supplies `previousData` in the state, that value takes priority. The widget's local cache is purely a fallback.
:::

---

### Displaying a freshness timestamp

`Success` carries `updatedAt` — the moment the data was last fetched:

```dart [user_screen.dart]
onSuccess: (user, updatedAt) => Column(
  children: [
    UserCard(user: user),
    Text(
      'Last updated ${_timeAgo(updatedAt)}',
      style: Theme.of(context).textTheme.labelSmall,
    ),
  ],
),
```

---

### Polling

Pass `refetchInterval` via `options` to poll on a fixed schedule:

```dart [notifications_screen.dart]
QoraBuilder<List<Notification>>(
  queryKey: ['notifications'],
  queryFn: api.getNotifications,
  options: const QoraOptions(refetchInterval: Duration(seconds: 30)),
  builder: (context, state) { ... },
)
```

Polling is active only while the `QoraBuilder` is in the widget tree. It stops automatically on dispose.

---

## Key Changing Behaviour

When `queryKey` changes (`didUpdateWidget`), `QoraBuilder`:

1. Cancels the previous stream subscription.
2. Subscribes to the new key's stream (starting from its current cache state — could be `Initial`, `Success`, etc.).
3. Dispatches a fresh `fetchQuery` for the new key (if `enabled`).

This is how pagination, tab switching, and filter changes are handled automatically without any extra state management.

---

## `QoraStateBuilder` — Observe Without Fetching

`QoraStateBuilder<T>` subscribes to query state without triggering a fetch. Use it when another widget or service owns the fetch lifecycle and you only want to display the current state.

```dart [notification_badge.dart]
// NotificationsScreen (a QoraBuilder) owns the fetch.
// This badge simply mirrors the cached state of the same key.
QoraStateBuilder<List<Notification>>(
  queryKey: ['notifications'],
  builder: (context, state) {
    final count = state.dataOrNull?.length ?? 0;
    return Badge(
      label: Text('$count'),
      isLabelVisible: count > 0,
      child: const Icon(Icons.notifications),
    );
  },
)
```

### `QoraStateBuilder` Props

| Prop       | Type                                          | Description                                    |
| ---------- | --------------------------------------------- | ---------------------------------------------- |
| `queryKey` | `Object` (`List` or `QoraKey`)                | Key to observe.                                |
| `builder`  | `Widget Function(BuildContext, QoraState<T>)` | Builds the widget tree from the current state. |
| `client`   | `QoraClient?`                                 | Override the client from `QoraScope`.          |

:::tip
`QoraStateBuilder` is ideal for badges, counters, or secondary displays that derive their data from a query fetched elsewhere — for example, a cart item count or an unread message badge in an app bar.
:::

---

## Next Steps

- [Query States](../core-concepts/query-states.md) — Full state machine reference
- [QoraOptions](../api-reference/qora-options.md) — Stale time, retry, and polling configuration
- [Optimistic Updates](../guides/optimistic-updates.md) — Instant UI with safe rollback
