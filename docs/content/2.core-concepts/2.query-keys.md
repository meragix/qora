---
title: Query Keys
description: Query keys are the foundation of Qora's caching system. They uniquely identify queries and enable automatic cache management, invalidation, and refetching.
---

## Overview

At its core, a query key is a **serializable array** that Qora uses to:

- **Cache data** uniquely per query
- **Automatically refetch** when keys change
- **Share data** across your app
- **Invalidate** and update related queries

Qora supports **two syntaxes** for maximum flexibility:

```dart
// Direct List (frictionless)
client.fetch(key: ['users', userId], ...);

// Typed Wrapper (type-safe)
client.fetch(key: QoraKey.withId('users', userId), ...);
```

Both are **100% interchangeable** and use the same underlying system.

---

## Query Keys Basics

### Simple Keys

The simplest form is a single-element array:

```dart
// Fetch all users
final users = await client.fetch(
  key: ['users'],
  fetcher: fetchUsers,
);

// Fetch app settings
final settings = await client.fetch(
  key: ['settings'],
  fetcher: fetchSettings,
);
```

### Keys with Variables

Keys can include dynamic values like IDs or filters:

```dart
// Fetch a specific user
final user = await client.fetch(
  key: ['user', userId],
  fetcher: () => fetchUser(userId),
);

// Fetch filtered posts
final posts = await client.fetch(
  key: ['posts', {'status': 'published', 'author': authorId}],
  fetcher: () => fetchPosts(status: 'published', author: authorId),
);
```

### Hierarchical Keys

Structure keys hierarchically to model relationships:

```dart
// User profile
['user', userId, 'profile']

// User's posts
['user', userId, 'posts']

// Specific post comments
['post', postId, 'comments']

// Paginated data
['posts', {'page': 2, 'limit': 20}]
```

---

## Key Equality

Qora uses **deep equality** to compare query keys. Two keys are equal if their **content** is identical, not their reference.

### Primitive Values

```dart
['users', 1] == ['users', 1]  // ✅ true
['users', 1] == ['users', 2]  // ❌ false
```

### Lists and Nesting

```dart
['users', [1, 2, 3]] == ['users', [1, 2, 3]]  // ✅ true
['users', [1, 2]] == ['users', [2, 1]]        // ❌ false (order matters)
```

### Maps (Order-Independent)

Maps are compared by their **content**, regardless of key order:

```dart
['posts', {'status': 'active', 'limit': 10}] 
  == 
['posts', {'limit': 10, 'status': 'active'}]  // ✅ true
```

This is a **critical difference** from TanStack Query (JavaScript), where object key order matters.

### Null Values

```dart
['user', null] == ['user', null]  // ✅ true
['user', null] == ['user', 1]     // ❌ false
```

---

## Query Key Structure

### Recommended Patterns

#### Pattern 1: Entity + ID

```dart
// Fetch a single resource
['user', userId]
['post', postId]
['product', sku]
```

#### Pattern 2: Entity + Filters

```dart
// List with filters
['posts', {'status': 'published'}]
['users', {'role': 'admin', 'active': true}]
['products', {'category': 'electronics', 'inStock': true}]
```

#### Pattern 3: Entity + ID + Relation

```dart
// Nested resources
['user', userId, 'posts']
['post', postId, 'comments']
['order', orderId, 'items']
```

#### Pattern 4: Pagination

```dart
// Infinite scroll
['posts', {'page': pageNumber}]

// Cursor-based
['messages', {'cursor': lastMessageId, 'limit': 50}]
```

### Anti-Patterns

❌ **Don't** include non-serializable objects:

```dart
['user', StreamController()]  // WRONG: Not serializable
['data', widget]              // WRONG: Widget instance
```

❌ **Don't** include computed values:

```dart
['posts', DateTime.now()]     // WRONG: Non-deterministic
['user', Random().nextInt()]  // WRONG: Changes on every call
```

❌ **Don't** nest too deeply:

```dart
['a', ['b', ['c', ['d', 'e']]]]  // WRONG: Hard to reason about
```

✅ **Do** keep it flat and predictable:

```dart
['posts', {'status': 'published', 'limit': 10}]  // GOOD
```

---

## Using Custom Objects in Keys

Custom objects can be used in keys if they implement **proper equality**.

### With Equatable

```dart [post_filter.dart]
import 'package:equatable/equatable.dart';

@immutable
class PostFilter extends Equatable {
  final String status;
  final int limit;

  const PostFilter({required this.status, required this.limit});

  @override
  List<Object?> get props => [status, limit];
}

// Usage
final posts = await client.fetch(
  key: ['posts', PostFilter(status: 'published', limit: 10)],
  fetcher: () => fetchPosts(...),
);
```

### Manual Override

```dart [user_query.dart]
@immutable
class UserQuery {
  final String role;
  final int minAge;

  const UserQuery({required this.role, required this.minAge});

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UserQuery && 
      role == other.role && 
      minAge == other.minAge;

  @override
  int get hashCode => Object.hash(role, minAge);
}
```

### Warning

⚠️ **Without proper equality, caching will fail silently:**

```dart [bad_filter.dart]
class BadFilter {
  final String status;
  BadFilter(this.status);
  // No == override → Each instance is unique
}

// Cache will NEVER hit:
await client.fetch(
  key: ['posts', BadFilter('published')],  // Instance 1
  fetcher: ...,
);

await client.fetch(
  key: ['posts', BadFilter('published')],  // Instance 2 (different reference)
  fetcher: ..., // Will refetch, not use cache
);
```

---

## The QoraKey Class (Optional)

For type safety and validation, use the `QoraKey` wrapper class.

### Factory Constructors

#### Single-Part Key

```dart
final settings = await client.fetch(
  key: QoraKey.single('settings'),
  fetcher: fetchSettings,
);
```

#### Entity + ID

```dart
final user = await client.fetch(
  key: QoraKey.withId('user', userId),
  fetcher: () => fetchUser(userId),
);
```

#### Entity + Filter

```dart
final posts = await client.fetch(
  key: QoraKey.withFilter('posts', {'status': 'published'}),
  fetcher: () => fetchPosts(status: 'published'),
);
```

#### Custom Construction

```dart
final key = QoraKey(['custom', 'key', 'parts']);
```

### When to Use QoraKey

Use `QoraKey` when:

- ✅ You want **explicit type safety**
- ✅ Building a **shared query key factory**
- ✅ Working in a **large team** (self-documenting code)

Use raw `List` when:

- ✅ Rapid prototyping
- ✅ Simple, one-off queries
- ✅ You prefer minimal syntax

---

## Query Key Factories

Create centralized key factories for consistency and reusability.

### Basic Factory

```dart [query_keys.dart]
class QueryKeys {
  // Simple keys
  static const settings = QoraKey(['settings']);
  static const currentUser = QoraKey(['user', 'current']);
  
  // Dynamic keys
  static QoraKey user(String id) => QoraKey.withId('user', id);
  
  static QoraKey userPosts(String userId) => 
    QoraKey(['user', userId, 'posts']);
  
  static QoraKey posts({String? status, int? limit}) =>
    QoraKey.withFilter('posts', {
      if (status != null) 'status': status,
      if (limit != null) 'limit': limit,
    });
}

// Usage
await client.fetch(
  key: QueryKeys.user('123'),
  fetcher: () => fetchUser('123'),
);

await client.fetch(
  key: QueryKeys.posts(status: 'published', limit: 10),
  fetcher: () => fetchPosts(...),
);
```

### Advanced Factory with Prefix Invalidation

```dart [post_query_keys.dart]
class PostQueryKeys {
  static const _prefix = ['posts'];
  
  // All posts
  static List<dynamic> get all => _prefix;
  
  // Filtered lists
  static List<dynamic> list([Map<String, dynamic>? filters]) =>
    filters != null ? [..._prefix, 'list', filters] : [..._prefix, 'list'];
  
  // Single post
  static List<dynamic> detail(String id) => [..._prefix, 'detail', id];
  
  // Post comments
  static List<dynamic> comments(String id) => 
    [..._prefix, 'detail', id, 'comments'];
}

// Usage
await client.fetch(
  key: PostQueryKeys.detail('123'),
  fetcher: () => fetchPost('123'),
);

// Invalidate all post-related queries
client.invalidateMatching((key) => 
  key.length > 0 && key[0] == 'posts'
);
```

---

## Invalidation Strategies

### Exact Match Invalidation

Invalidate a specific query:

```dart
// Invalidate exact key
client.invalidate(['user', userId]);
```

### Pattern-Based Invalidation (Future Feature)

```dart
// Invalidate all user queries
client.invalidateMatching((key) => key[0] == 'user');

// Invalidate all queries for a specific user
client.invalidateMatching((key) => 
  key.length >= 2 && key[0] == 'user' && key[1] == userId
);

// Invalidate all posts with a specific status
client.invalidateMatching((key) =>
  key[0] == 'posts' && 
  key.length > 1 && 
  key[1] is Map && 
  key[1]['status'] == 'published'
);
```

### Hierarchical Invalidation

Structure keys for easy batch invalidation:

```dart
// Fetch user
await client.fetch(key: ['user', userId], ...);

// Fetch user's posts
await client.fetch(key: ['user', userId, 'posts'], ...);

// Fetch user's comments
await client.fetch(key: ['user', userId, 'comments'], ...);

// Invalidate ALL user-related data
client.invalidateMatching((key) => 
  key.length >= 2 && key[0] == 'user' && key[1] == userId
);
```

---

## Cross-Pattern Compatibility

List and QoraKey are **100% interchangeable**:

```dart
// Set with List
await client.fetch(
  key: ['user', 123],
  fetcher: () => fetchUser(123),
);

// Get with QoraKey (cache hit!)
await client.fetch(
  key: QoraKey.withId('user', 123),
  fetcher: () => throw Exception('Not called'),
);

// Invalidate with List
client.invalidate(['user', 123]);

// Or invalidate with QoraKey
client.invalidate(QoraKey.withId('user', 123));
```

---

## Performance Considerations

### Key Normalization Cost

Every key is **deep-copied** and made immutable for safety:

```dart
final key = ['user', 123];
client.fetch(key: key, ...); // O(n) copy where n = key depth

// After this, mutating the original has no effect:
key.add('hacked'); // ❌ Doesn't affect cache
```

**Best Practice**: For frequently-used keys, use `const`:

```dart
class QueryKeys {
  static const settings = QoraKey(['settings']);
  static const currentUser = QoraKey(['user', 'current']);
}

// No allocation on repeated calls
await client.fetch(key: QueryKeys.settings, ...);
```

### Hashing Performance

| Key Complexity                | Hash Time (1000 ops) | Notes                |
|-------------------------------|----------------------|----------------------|
| `['simple']`                  | ~1ms                 | Fastest              |
| `['user', 123]`               | ~2ms                 | Typical              |
| `['posts', {'a': 1, 'b': 2}]` | ~5ms                 | Map sorting overhead |
| Deep nesting (3+ levels)      | ~10ms                | Avoid if possible    |

**Recommendation**: Keep keys shallow (≤ 3 levels).

---

## Best Practices Summary

### ✅ DO

```dart
// Use primitives
['user', 123, 'profile']

// Use Maps for filters
['posts', {'status': 'published', 'limit': 10}]

// Keep it hierarchical
['entity', id, 'relation']

// Use factories for reusability
QueryKeys.user(userId)

// Use const for static keys
static const settings = QoraKey(['settings']);
```

### ❌ DON'T

```dart
// Non-serializable objects
['user', StreamController()]

// Non-deterministic values
['posts', DateTime.now()]

// Deep nesting
['a', ['b', ['c', ['d']]]]

// Objects without == override
['filter', BrokenClass()]

// Mutate keys after use (pointless, already copied)
final key = ['user', 1];
client.fetch(key: key, ...);
key.add('extra'); // ❌ No effect
```

---

## Common Patterns

### Pagination

```dart
// Offset-based
['posts', {'page': pageNumber, 'limit': 20}]

// Cursor-based
['messages', {'cursor': lastId, 'limit': 50}]

// Infinite scroll (separate queries per page)
for (int page = 1; page <= 3; page++) {
  await client.fetch(
    key: ['posts', {'page': page}],
    fetcher: () => fetchPosts(page: page),
  );
}
```

### Search & Filtering

```dart
// Search query
['search', {'q': searchTerm, 'type': 'users'}]

// Complex filters
['products', {
  'category': 'electronics',
  'inStock': true,
  'priceRange': {'min': 100, 'max': 500},
}]
```

### Dependent Queries

```dart
// Step 1: Fetch user
final user = await client.fetch(
  key: ['user', userId],
  fetcher: () => fetchUser(userId),
);

// Step 2: Fetch user's posts (dependent on step 1)
final posts = await client.fetch(
  key: ['user', userId, 'posts'],
  fetcher: () => fetchUserPosts(userId),
);
```

### Optimistic Updates

```dart
// Update user locally
client.setQueryData(
  key: ['user', userId],
  data: updatedUser,
);

// Trigger mutation
await updateUserOnServer(updatedUser);

// Invalidate to refetch
client.invalidate(['user', userId]);
```

---

## Troubleshooting

### Problem: Cache always misses

**Symptom**: Every fetch refetches, never hits cache.

**Diagnosis**:

```dart
// Debug keys
print(client.getQueryData(['user', 1])); // Check if data exists

// Compare keys
final key1 = ['user', customObject1];
final key2 = ['user', customObject2];
print(key1 == key2); // Should be true if caching should work
```

**Solution**: Ensure custom objects override `==` and `hashCode`.

---

### Problem: ArgumentError on key

**Symptom**: `ArgumentError: Key must be QoraKey or List<dynamic>`

**Cause**: Passing invalid type as key.

```dart
client.fetch(key: 'string', ...); // ❌ WRONG
```

**Solution**: Wrap in List or use QoraKey.

```dart
client.fetch(key: ['string'], ...); // ✅ CORRECT
```

---

### Problem: Unexpected refetches

**Symptom**: Query refetches even though key seems identical.

**Diagnosis**: Keys contain non-deterministic values.

```dart
// BAD: DateTime creates new instance each time
['posts', DateTime.now()]

// BAD: Random value changes
['data', Random().nextInt(100)]
```

**Solution**: Use stable, deterministic values.

```dart
// GOOD: Static timestamp
['posts', {'timestamp': fixedTimestamp}]

// GOOD: User-controlled values
['posts', {'status': status}]
```

---

## What's Next?

Now that you understand query keys, explore:

- **[Query States](./Qora_state.md)**: Learn about Loading, Success, and Error states
- **[QoraClient](./Qora_client.md)**: Master the core client API
- **[Invalidation](./invalidation.md)**: Advanced cache management
- **[Optimistic Updates](./optimistic_updates.md)**: Update UI before server responds

---

## Examples

### Real-World Repository

```dart [user.repository.dart]
class UserRepository {
  final QoraClient _client;

  UserRepository(this._client);

  // Fetch single user
  Future<User> getUser(String id) {
    return _client.fetch(
      key: ['user', id],
      fetcher: () => _api.fetchUser(id),
      decoder: (json) => User.fromJson(json),
    );
  }

  // Fetch all users with filters
  Future<List<User>> getUsers({String? role, bool? active}) {
    return _client.fetch(
      key: ['users', {
        if (role != null) 'role': role,
        if (active != null) 'active': active,
      }],
      fetcher: () async {
      final raw = await _api.fetchUsers(role: role, active: active);

      return raw
          .map((e) => User.fromJson(e as Map<String, dynamic>))
          .toList();
      },
    );
  }

  // Update user
  Future<User> updateUser(String id, Map<String, dynamic> updates) async {
    // Optimistically update cache
    final current = _client.getQueryData(['user', id]);
    if (current != null) {
      _client.setQueryData(['user', id], {...current, ...updates});
    }

    try {
      final updated = await _api.updateUser(id, updates);
      
      // Update cache with server response
      _client.setQueryData(['user', id], updated);
      
      // Invalidate user lists
      _client.invalidateMatching((key) => key[0] == 'users');
      
      return updated;
    } catch (e) {
      // Rollback on error
      if (current != null) {
        _client.setQueryData(['user', id], current);
      }
      rethrow;
    }
  }

  // Delete user
  Future<void> deleteUser(String id) async {
    await _api.deleteUser(id);
    
    // Remove from cache
    _client.removeQueryData(['user', id]);
    
    // Invalidate lists
    _client.invalidateMatching((key) => key[0] == 'users');
  }
}
```

### Query Key Constants

```dart [lib/core/query_keys.dart]
class QueryKeys {
  QueryKeys._(); // Private constructor

  // Auth
  static const currentUser = ['auth', 'current'];
  static const authStatus = ['auth', 'status'];

  // Users
  static List<dynamic> user(String id) => ['user', id];
  static List<dynamic> userProfile(String id) => ['user', id, 'profile'];
  static List<dynamic> users([Map<String, dynamic>? filters]) =>
    filters != null ? ['users', filters] : ['users'];

  // Posts
  static List<dynamic> post(String id) => ['post', id];
  static List<dynamic> posts({String? status, String? author}) =>
    ['posts', {
      if (status != null) 'status': status,
      if (author != null) 'author': author,
    }];
  static List<dynamic> postComments(String postId) =>
    ['post', postId, 'comments'];

  // Settings
  static const appSettings = ['settings', 'app'];
  static List<dynamic> userSettings(String userId) =>
    ['settings', 'user', userId];
}

// Usage across the app
await client.fetch(
  key: QueryKeys.user('123'),
  fetcher: () => fetchUser('123'),
);

client.invalidate(QueryKeys.posts(status: 'draft'));
```

---

**Ready to dive deeper?** Check out the [QoraClient Documentation](./Qora_client.md) to see how keys power the entire caching system.
