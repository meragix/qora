---
title: Stale-While-Revalidate
description: Qora's SWR strategy delivers instant responses from cache while silently fetching fresh data in the background — keeping UIs fast and data current.
---

## The Problem SWR Solves

Traditional data fetching has an uncomfortable tradeoff:

- **No cache** — always fresh, but every navigation shows a spinner
- **Permanent cache** — instant, but data goes stale and users see outdated information

SWR (Stale-While-Revalidate) eliminates this tradeoff.

---

## How It Works

When `fetchQuery` or `watchQuery` is called with stale data in cache:

1. **Return the stale data immediately** — UI renders instantly, no spinner
2. **Trigger a background revalidation** — fetch fresh data silently
3. **Update the cache and all active streams** when the fresh data arrives

```text
t=0:00  Success(user: Alice, updatedAt: 10:00)   ← staleTime: 5 min
t=5:01  fetchQuery called
         ├── returns Alice immediately (stale data)
         └── fires background fetch
t=5:02  Success(user: Alice McBride, updatedAt: 10:05)   ← updated
         └── watchQuery streams emit new state
```

---

## Configuring Stale Time

```dart [user_repository.dart]
// Default: Duration.zero — always stale, always revalidates
// (still serves cached data instantly on every call)
options: QoraOptions(staleTime: Duration.zero),

// Fresh for 5 minutes — no network call within the window
options: QoraOptions(staleTime: Duration(minutes: 5)),

// Configuration data — only revalidates once per hour
options: QoraOptions(staleTime: Duration(hours: 1)),
```

### Choosing `staleTime` by data type

| Data type                    | Recommended `staleTime` |
| ---------------------------- | ----------------------- |
| Live prices, notifications   | `Duration.zero`         |
| User profile, settings       | `Duration(minutes: 5)`  |
| Post / article content       | `Duration(minutes: 10)` |
| Rarely-changing config       | `Duration(hours: 1)`    |
| Static reference data        | `Duration(days: 1)`     |

---

## SWR with `fetchQuery`

When `fetchQuery` hits a stale cache entry, it returns the stale data synchronously and fires a revalidation in the background. The call resolves immediately:

```dart [user_repository.dart]
// This returns immediately with cached data if available
final user = await client.fetchQuery<User>(
  key: ['users', userId],
  fetcher: () => api.getUser(userId),
  options: QoraOptions(staleTime: Duration(minutes: 5)),
);

// If data was stale:
// - `user` is the stale value (returned instantly)
// - A background fetch is already in progress
// - Active watchQuery streams will receive the updated user when the fetch completes
```

---

## SWR with `watchQuery`

`watchQuery` streams are the natural fit for SWR. Subscribers always get the latest state, including the background revalidation result:

```dart [user_page.dart]
StreamBuilder<QoraState<User>>(
  stream: client.watchQuery<User>(
    key: ['users', userId],
    fetcher: () => api.getUser(userId),
    options: QoraOptions(staleTime: Duration(minutes: 5)),
  ),
  builder: (context, snapshot) {
    return switch (snapshot.data) {
      // Shows stale data instantly while Loading(previousData: user) is emitted
      Loading(:final previousData) when previousData != null =>
        Stack(children: [
          UserCard(previousData),
          const LinearProgressIndicator(),
        ]),
      Success(:final data) => UserCard(data),
      Failure(:final error, :final previousData) => Column(children: [
          if (previousData != null) UserCard(previousData),
          ErrorBanner('$error'),
        ]),
      _ => const CircularProgressIndicator(),
    };
  },
)
```

### State sequence on mount with stale cache

```text
Subscription starts
  ↓ emits immediately
Loading(previousData: Alice)    ← stale data visible, subtle loading indicator
  ↓ fetch completes
Success(data: Alice McBride)    ← fresh data, UI updates seamlessly
```

---

## Refetch on Mount

By default, `watchQuery` always fetches on the first subscription if data is stale. Control this behaviour with `refetchOnMount`:

```dart [main.dart]
// Always refetch on mount (default)
options: QoraOptions(refetchOnMount: true),

// Only fetch if no data at all — never refetch fresh or stale cached data
options: QoraOptions(refetchOnMount: false),

// Use the global QoraClientConfig.refetchOnMount setting
options: QoraOptions(refetchOnMount: null),
```

---

## Polling (Active Revalidation)

For live data, combine SWR with `refetchInterval` to actively keep data current:

```dart [dashboard_page.dart]
client.watchQuery<Stats>(
  key: ['dashboard', 'stats'],
  fetcher: api.getDashboardStats,
  options: QoraOptions(
    staleTime: Duration(seconds: 10),
    refetchInterval: Duration(seconds: 30),
  ),
)
```

The interval timer:

- **Starts** when the first subscriber attaches
- **Fires** every `refetchInterval`, triggering a background fetch
- **Stops** when the last subscriber cancels (no polling for invisible screens)

---

## Force Refresh

To bypass the stale check and always fetch fresh data, use `invalidate` before fetching:

```dart [main.dart]
// Force a fresh fetch on next access
client.invalidate(['users', userId]);

// Or immediately prefetch fresh data
await client.prefetch<User>(
  key: ['users', userId],
  fetcher: () => api.getUser(userId),
  options: QoraOptions(staleTime: Duration.zero),
);
```

---

## Next Steps

- [Deduplication](./deduplication.md) — How concurrent callers share a single request
- [Caching](./caching.md) — LRU, GC, and `cacheTime` vs `staleTime`
- [QoraOptions API](/api-reference/qora-options) — Full options reference
