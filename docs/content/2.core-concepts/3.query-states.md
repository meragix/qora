---
title: Query States
description: Query states represent the lifecycle of your data fetching operations. Qora uses **sealed classes** to provide exhaustive, type-safe state handling that prevents runtime errors.
---

## Overview

Every query in Qora exists in one of four states:

```dart [lib/src/core/qora_state.dart]
sealed class QoraState<T> {
  const QoraState();
}

// Initial: Query hasn't started
class Initial<T> extends QoraState<T> {
  const Initial();
}

// Loading: Fetching data (with optional previous data)
class Loading<T> extends QoraState<T> {
  final T? previousData;
  const Loading({this.previousData});
}

// Success: Data fetched successfully
class Success<T> extends QoraState<T> {
  final T data;
  final DateTime updatedAt;
  const Success({required this.data, required this.updatedAt});
}

// Error: Fetch failed (with optional previous data)
class Error<T> extends QoraState<T> {
  final Object error;
  final StackTrace? stackTrace;
  final T? previousData;
  const Error({
    required this.error,
    this.stackTrace,
    this.previousData,
  });
}
```

This design enables **exhaustive pattern matching** with Dart 3's sealed classes.

---

## State Transitions

### Visual Flow

```bash
Initial
  ↓ fetch()
Loading(previousData: null)
  ↓ success
Success(data)
  ↓ refetch()
Loading(previousData: data)
  ↓ success
Success(newData)
  ↓ error
Error(error, previousData: data)
```

### Key Principles

1. **previousData preservation**: Users see old data while new data loads
2. **Optimistic UI**: Display stale data instead of spinners
3. **Graceful degradation**: Errors don't destroy existing data

---

## Pattern Matching

Qora's sealed classes force **exhaustive handling** at compile-time.

### Basic Pattern Matching

```dart [main.dart]
final state = await client.fetchStream(
  key: ['user', userId],
  fetcher: () => fetchUser(userId),
).first;

// Exhaustive switch (Dart 3)
switch (state) {
  case Initial():
    print('Not started yet');
  
  case Loading(:final previousData):
    if (previousData != null) {
      print('Refreshing... showing: $previousData');
    } else {
      print('Loading for first time...');
    }
  
  case Success(:final data, :final updatedAt):
    print('Success! Data: $data (updated: $updatedAt)');
  
  case Error(:final error, :final previousData):
    print('Error: $error');
    if (previousData != null) {
      print('But we still have: $previousData');
    }
}
```

### Widget Integration (Flutter)

```dart [main.dart]
StreamBuilder<QoraState<User>>(
  stream: client.stream(key: ['user', userId]),
  builder: (context, snapshot) {
    if (!snapshot.hasData) return SizedBox();
    
    final state = snapshot.data!;
    
    return switch (state) {
      Initial() => Center(child: Text('Ready to load')),
      
      Loading(:final previousData) => Stack(
        children: [
          if (previousData != null) UserCard(user: previousData),
          LinearProgressIndicator(),
        ],
      ),
      
      Success(:final data) => UserCard(user: data),
      
      Error(:final error, :final previousData) => Column(
        children: [
          if (previousData != null) UserCard(user: previousData),
          ErrorBanner(error: error),
        ],
      ),
    };
  },
)
```

---

## Initial State

The starting state before any data fetching occurs.

### Characteristics

- **No data**: Query hasn't run yet
- **No loading**: Not actively fetching
- **Transitions to**: `Loading` on first fetch

### When You See Initial

```dart
// Immediately after creating a stream (before first fetch)
final stream = client.stream(
  key: ['users'],
  fetcher: fetchUsers,
);

// First emission is Initial
stream.listen((state) {
  print(state); // Initial()
});
```

### Common Use Cases

#### Lazy Loading

```dart [user_profile_widget.dart]
// Don't fetch until user clicks
class UserProfileWidget extends StatefulWidget {
  @override
  State<UserProfileWidget> createState() => _UserProfileWidgetState();
}

class _UserProfileWidgetState extends State<UserProfileWidget> {
  Stream<QoraState<User>>? _userStream;

  void _loadUser() {
    setState(() {
      _userStream = client.stream(
        key: ['user', widget.userId],
        fetcher: () => fetchUser(widget.userId),
      );
    });
  }

  @override
  Widget build(BuildContext context) {
    if (_userStream == null) {
      return ElevatedButton(
        onPressed: _loadUser,
        child: Text('Load Profile'),
      );
    }

    return StreamBuilder<QoraState<User>>(
      stream: _userStream,
      builder: (context, snapshot) {
        // Handle states...
      },
    );
  }
}
```

#### Conditional Fetching

```dart
// Only fetch if search query is valid
Stream<QoraState<List<Product>>>? searchStream(String query) {
  if (query.length < 3) return null; // Don't search short queries
  
  return client.stream(
    key: ['search', {'q': query}],
    fetcher: () => searchProducts(query),
  );
}
```

---

## Loading State

Indicates an active fetch operation.

### Properties

```dart
class Loading<T> extends QoraState<T> {
  final T? previousData;  // Data from previous successful fetch
  const Loading({this.previousData});
}
```

### previousData Behavior

#### First Fetch (No Previous Data)

```dart
// User visits page for first time
Loading(previousData: null)

// UI: Show full-screen spinner
if (state is Loading && state.previousData == null) {
  return CircularProgressIndicator();
}
```

#### Refetch (Has Previous Data)

```dart
// User pulls to refresh
Loading(previousData: oldUser)

// UI: Show stale data + subtle indicator
if (state is Loading && state.previousData != null) {
  return Stack(
    children: [
      UserCard(user: state.previousData!),  // Keep showing old data
      Positioned(
        top: 0,
        left: 0,
        right: 0,
        child: LinearProgressIndicator(),
      ),
    ],
  );
}
```

### Common Patterns

#### Background Refresh

```dart
switch (state) {
  case Loading(:final previousData):
    return Column(
      children: [
        if (previousData != null) 
          Opacity(
            opacity: 0.6,
            child: DataList(items: previousData),
          ),
        if (previousData == null)
          Center(child: CircularProgressIndicator()),
      ],
    );
  // ... other cases
}
```

#### Pull-to-Refresh

```dart
RefreshIndicator(
  onRefresh: () async {
    client.invalidate(['posts']);
    
    // Wait for Success or Error
    await client
      .stream(key: ['posts'], fetcher: fetchPosts)
      .firstWhere((state) => state is Success || state is Error);
  },
  child: StreamBuilder<QoraState<List<Post>>>(
    stream: client.stream(key: ['posts'], fetcher: fetchPosts),
    builder: (context, snapshot) {
      // Handle states...
    },
  ),
)
```

#### Skeleton Screens

```dart
case Loading(:final previousData):
  if (previousData == null) {
    return Shimmer.fromColors(
      baseColor: Colors.grey[300]!,
      highlightColor: Colors.grey[100]!,
      child: SkeletonUserCard(),
    );
  }
  return UserCard(user: previousData);
```

---

## Success State

Represents successfully fetched data.

### Properties

```dart
class Success<T> extends QoraState<T> {
  final T data;           // The fetched data
  final DateTime updatedAt;  // When this data was fetched
  const Success({required this.data, required this.updatedAt});
}
```

### updatedAt Usage

#### Show Freshness

```dart
case Success(:final data, :final updatedAt):
  final age = DateTime.now().difference(updatedAt);
  
  return Column(
    children: [
      DataDisplay(data: data),
      Text(
        'Updated ${_formatAge(age)}',
        style: TextStyle(fontSize: 12, color: Colors.grey),
      ),
    ],
  );

String _formatAge(Duration age) {
  if (age.inMinutes < 1) return 'just now';
  if (age.inMinutes < 60) return '${age.inMinutes}m ago';
  if (age.inHours < 24) return '${age.inHours}h ago';
  return '${age.inDays}d ago';
}
```

#### Stale-While-Revalidate

```dart
client.stream(
  key: ['posts'],
  fetcher: fetchPosts,
  staleTime: Duration(minutes: 5),
  refetchInterval: Duration(minutes: 1),
).listen((state) {
  if (state is Success) {
    final age = DateTime.now().difference(state.updatedAt);
    
    if (age > Duration(minutes: 5)) {
      print('Data is stale, but still usable');
    }
  }
});
```

#### Cache Debugging

```dart
void debugCacheState() {
  final state = client.getQueryState(['users']);
  
  if (state is Success<List<User>>) {
    print('Cached users: ${state.data.length}');
    print('Last updated: ${state.updatedAt}');
    print('Age: ${DateTime.now().difference(state.updatedAt)}');
  }
}
```

---

## Error State

Represents a failed fetch operation.

### Properties

```dart
class Error<T> extends QoraState<T> {
  final Object error;         // The error object
  final StackTrace? stackTrace;  // Optional stack trace
  final T? previousData;      // Data from previous successful fetch
  
  const Error({
    required this.error,
    this.stackTrace,
    this.previousData,
  });
}
```

### previousData in Errors

The **critical difference** from most state management: errors preserve previous data.

#### Graceful Degradation

```dart
case Error(:final error, :final previousData):
  if (previousData != null) {
    // Show stale data with error banner
    return Column(
      children: [
        ErrorBanner(
          message: 'Failed to refresh. Showing cached data.',
          onRetry: () => client.invalidate(['posts']),
        ),
        Opacity(
          opacity: 0.7,
          child: PostList(posts: previousData),
        ),
      ],
    );
  } else {
    // No previous data, show full error screen
    return ErrorScreen(
      error: error,
      onRetry: () => client.invalidate(['posts']),
    );
  }
```

### Error Handling Patterns

#### Retry with Exponential Backoff

```dart
class RetryableQuery<T> {
  final QoraClient client;
  int _retryCount = 0;

  Stream<QoraState<T>> fetch({
    required List<dynamic> key,
    required Future<T> Function() fetcher,
    int maxRetries = 3,
  }) {
    return client.stream(key: key, fetcher: fetcher).map((state) {
      if (state is Error && _retryCount < maxRetries) {
        final delay = Duration(seconds: math.pow(2, _retryCount).toInt());
        
        Future.delayed(delay, () {
          _retryCount++;
          client.invalidate(key);
        });
      } else if (state is Success) {
        _retryCount = 0; // Reset on success
      }
      
      return state;
    });
  }
}
```

#### Error Type Differentiation

```dart
case Error(:final error, :final previousData):
  if (error is NetworkException) {
    return OfflineErrorWidget(
      previousData: previousData,
      onRetry: () => client.invalidate(['posts']),
    );
  } else if (error is AuthException) {
    return AuthErrorWidget(
      onLogin: () => Navigator.pushNamed(context, '/login'),
    );
  } else if (error is ValidationException) {
    return ValidationErrorWidget(
      errors: error.errors,
      previousData: previousData,
    );
  } else {
    return GenericErrorWidget(
      error: error,
      onRetry: () => client.invalidate(['posts']),
    );
  }
```

#### Error Logging

```dart
client.stream(key: ['users'], fetcher: fetchUsers).listen((state) {
  if (state is Error) {
    // Log to analytics
    analytics.logError(
      error: state.error,
      stackTrace: state.stackTrace,
      context: {
        'query_key': 'users',
        'had_previous_data': state.previousData != null,
      },
    );
    
    // Log to console in debug
    if (kDebugMode) {
      print('Query error: ${state.error}');
      if (state.stackTrace != null) {
        print(state.stackTrace);
      }
    }
  }
});
```

#### Sentry Integration

```dart
Stream<QoraState<T>> monitoredFetch<T>({
  required List<dynamic> key,
  required Future<T> Function() fetcher,
}) {
  return client.stream(key: key, fetcher: fetcher).map((state) {
    if (state is Error) {
      Sentry.captureException(
        state.error,
        stackTrace: state.stackTrace,
        hint: Hint.withMap({
          'query_key': key.toString(),
          'has_stale_data': state.previousData != null,
        }),
      );
    }
    return state;
  });
}
```

---

## Advanced State Handling

### Combining Multiple States

#### Dependent Queries

```dart [main.dart]
// Fetch user, then their posts
StreamBuilder<QoraState<User>>(
  stream: client.stream(key: ['user', userId], fetcher: () => fetchUser(userId)),
  builder: (context, userSnapshot) {
    if (!userSnapshot.hasData) return SizedBox();
    
    final userState = userSnapshot.data!;
    
    return switch (userState) {
      Initial() || Loading(previousData: null) => CircularProgressIndicator(),
      
      Success(:final data) => StreamBuilder<QoraState<List<Post>>>(
        stream: client.stream(
          key: ['user', userId, 'posts'],
          fetcher: () => fetchUserPosts(userId),
        ),
        builder: (context, postsSnapshot) {
          if (!postsSnapshot.hasData) return CircularProgressIndicator();
          
          final postsState = postsSnapshot.data!;
          
          return switch (postsState) {
            Success(:final data) => UserWithPosts(user: data, posts: data),
            _ => CircularProgressIndicator(),
          };
        },
      ),
      
      _ => ErrorWidget(userState),
    };
  },
)
```

#### Parallel Queries

```dart [models/dashboard_data.dart]
class DashboardData {
  final User user;
  final List<Post> posts;
  final Settings settings;
  
  DashboardData({
    required this.user,
    required this.posts,
    required this.settings,
  });
}

Stream<QoraState<DashboardData>> combinedDashboard() {
  return Rx.combineLatest3<
    QoraState<User>,
    QoraState<List<Post>>,
    QoraState<Settings>,
    QoraState<DashboardData>
  >(
    client.stream(key: ['user', 'current'], fetcher: fetchCurrentUser),
    client.stream(key: ['posts'], fetcher: fetchPosts),
    client.stream(key: ['settings'], fetcher: fetchSettings),
    (userState, postsState, settingsState) {
      // All must be Success
      if (userState is Success<User> &&
          postsState is Success<List<Post>> &&
          settingsState is Success<Settings>) {
        return Success(
          data: DashboardData(
            user: userState.data,
            posts: postsState.data,
            settings: settingsState.data,
          ),
          updatedAt: DateTime.now(),
        );
      }
      
      // Any loading?
      if (userState is Loading || postsState is Loading || settingsState is Loading) {
        return Loading<DashboardData>();
      }
      
      // Any error?
      if (userState is Error) {
        return Error(error: userState.error);
      }
      if (postsState is Error) {
        return Error(error: postsState.error);
      }
      if (settingsState is Error) {
        return Error(error: settingsState.error);
      }
      
      return Initial<DashboardData>();
    },
  );
}
```

### Custom State Extensions

#### Helper Methods

```dart [main.dart]
extension QoraStateX<T> on QoraState<T> {
  /// Check if state has usable data (Success or Loading/Error with previousData)
  bool get hasData => switch (this) {
    Success() => true,
    Loading(:final previousData) => previousData != null,
    Error(:final previousData) => previousData != null,
    _ => false,
  };
  
  /// Extract data regardless of state (null if unavailable)
  T? get dataOrNull => switch (this) {
    Success(:final data) => data,
    Loading(:final previousData) => previousData,
    Error(:final previousData) => previousData,
    _ => null,
  };
  
  /// Is actively loading?
  bool get isLoading => this is Loading;
  
  /// Is in error state?
  bool get isError => this is Error;
  
  /// Is successful?
  bool get isSuccess => this is Success;
  
  /// Is initial?
  bool get isInitial => this is Initial;
  
  /// Get error or null
  Object? get errorOrNull => switch (this) {
    Error(:final error) => error,
    _ => null,
  };
  
  /// Map the data type
  QoraState<R> map<R>(R Function(T data) transform) {
    return switch (this) {
      Initial() => Initial<R>(),
      Loading(:final previousData) => Loading<R>(
        previousData: previousData != null ? transform(previousData) : null,
      ),
      Success(:final data, :final updatedAt) => Success<R>(
        data: transform(data),
        updatedAt: updatedAt,
      ),
      Error(:final error, :final stackTrace, :final previousData) => Error<R>(
        error: error,
        stackTrace: stackTrace,
        previousData: previousData != null ? transform(previousData) : null,
      ),
    };
  }
}

// Usage
final state = client.getQueryState<List<User>>(['users']);

if (state.hasData) {
  final users = state.dataOrNull!;
  print('Users: ${users.length}');
}

// Transform data type
final userNamesState = state.map((users) => users.map((u) => u.name).toList());
```

#### Conditional Rendering Helper

```dart [main.dart]
Widget buildFromState<T>({
  required QoraState<T> state,
  required Widget Function(T data) onSuccess,
  Widget Function()? onInitial,
  Widget Function(T? previousData)? onLoading,
  Widget Function(Object error, T? previousData)? onError,
}) {
  return switch (state) {
    Initial() => onInitial?.call() ?? SizedBox(),
    
    Loading(:final previousData) => 
      onLoading?.call(previousData) ?? CircularProgressIndicator(),
    
    Success(:final data) => onSuccess(data),
    
    Error(:final error, :final previousData) =>
      onError?.call(error, previousData) ?? 
      Text('Error: $error'),
  };
}

// Usage
buildFromState(
  state: userState,
  onSuccess: (user) => UserProfile(user: user),
  onLoading: (previousUser) => Stack(
    children: [
      if (previousUser != null) UserProfile(user: previousUser),
      LinearProgressIndicator(),
    ],
  ),
  onError: (error, previousUser) => Column(
    children: [
      if (previousUser != null) UserProfile(user: previousUser),
      ErrorBanner(error: error),
    ],
  ),
)
```

---

## State Persistence

### Serialize State

```dart [extension.dart]
extension QoraStateSerialization<T> on QoraState<T> {
  Map<String, dynamic> toJson(Map<String, dynamic> Function(T) dataToJson) {
    return switch (this) {
      Initial() => {'type': 'initial'},
      
      Loading(:final previousData) => {
        'type': 'loading',
        if (previousData != null) 'previousData': dataToJson(previousData),
      },
      
      Success(:final data, :final updatedAt) => {
        'type': 'success',
        'data': dataToJson(data),
        'updatedAt': updatedAt.toIso8601String(),
      },
      
      Error(:final error, :final previousData) => {
        'type': 'error',
        'error': error.toString(),
        if (previousData != null) 'previousData': dataToJson(previousData),
      },
    };
  }
  
  static QoraState<T> fromJson<T>(
    Map<String, dynamic> json,
    T Function(Map<String, dynamic>) dataFromJson,
  ) {
    switch (json['type']) {
      case 'initial':
        return Initial<T>();
      
      case 'loading':
        return Loading<T>(
          previousData: json['previousData'] != null
            ? dataFromJson(json['previousData'])
            : null,
        );
      
      case 'success':
        return Success<T>(
          data: dataFromJson(json['data']),
          updatedAt: DateTime.parse(json['updatedAt']),
        );
      
      case 'error':
        return Error<T>(
          error: json['error'],
          previousData: json['previousData'] != null
            ? dataFromJson(json['previousData'])
            : null,
        );
      
      default:
        return Initial<T>();
    }
  }
}

// Usage
final state = Success(data: user, updatedAt: DateTime.now());
final json = state.toJson((user) => user.toJson());

// Save to SharedPreferences
await prefs.setString('user_state', jsonEncode(json));

// Restore
final restoredJson = jsonDecode(prefs.getString('user_state')!);
final restoredState = QoraStateSerialization.fromJson<User>(
  restoredJson,
  (json) => User.fromJson(json),
);
```

---

## Testing States

### Unit Tests

```dart
test('Initial state has no data', () {
  const state = Initial<String>();
  
  expect(state.hasData, false);
  expect(state.dataOrNull, null);
  expect(state.isInitial, true);
});

test('Loading preserves previous data', () {
  const state = Loading<String>(previousData: 'old');
  
  expect(state.hasData, true);
  expect(state.dataOrNull, 'old');
  expect(state.isLoading, true);
});

test('Success contains data', () {
  final state = Success<String>(
    data: 'hello',
    updatedAt: DateTime.now(),
  );
  
  expect(state.hasData, true);
  expect(state.dataOrNull, 'hello');
  expect(state.isSuccess, true);
});

test('Error preserves previous data', () {
  const state = Error<String>(
    error: 'Network error',
    previousData: 'cached',
  );
  
  expect(state.hasData, true);
  expect(state.dataOrNull, 'cached');
  expect(state.isError, true);
  expect(state.errorOrNull, 'Network error');
});

test('State mapping transforms data type', () {
  final state = Success<int>(data: 42, updatedAt: DateTime.now());
  final mapped = state.map((n) => n.toString());
  
  expect(mapped, isA<Success<String>>());
  expect((mapped as Success<String>).data, '42');
});
```

### Widget Tests

```dart
testWidgets('Displays loading indicator on Loading state', (tester) async {
  await tester.pumpWidget(
    MaterialApp(
      home: buildFromState(
        state: Loading<String>(),
        onSuccess: (data) => Text(data),
        onLoading: (_) => CircularProgressIndicator(),
      ),
    ),
  );
  
  expect(find.byType(CircularProgressIndicator), findsOneWidget);
});

testWidgets('Shows previous data while loading', (tester) async {
  await tester.pumpWidget(
    MaterialApp(
      home: buildFromState(
        state: Loading<String>(previousData: 'Old Data'),
        onSuccess: (data) => Text(data),
        onLoading: (prev) => Column(
          children: [
            if (prev != null) Text(prev),
            CircularProgressIndicator(),
          ],
        ),
      ),
    ),
  );
  
  expect(find.text('Old Data'), findsOneWidget);
  expect(find.byType(CircularProgressIndicator), findsOneWidget);
});
```

---

## Best Practices

### ✅ DO

```dart
// Preserve previous data during refetch
Loading(previousData: currentData)

// Always handle all states exhaustively
switch (state) {
  case Initial(): ...
  case Loading(): ...
  case Success(): ...
  case Error(): ...
}

// Use extensions for common patterns
if (state.hasData) {
  final data = state.dataOrNull!;
}

// Show stale data with error indicator
case Error(:final previousData):
  if (previousData != null) {
    return Stack(children: [
      DataView(previousData),
      ErrorBanner(),
    ]);
  }
```

### ❌ DON'T

```dart
// Don't discard previous data on error
Error(error: e) // ❌ Missing previousData

// Don't use incomplete pattern matching
if (state is Success) { ... } // ❌ Ignores other states

// Don't show nothing on error with stale data
case Error():
  return ErrorScreen(); // ❌ Should show previousData if available

// Don't ignore updatedAt
case Success(:final data):
  return Display(data); // ❌ Consider showing freshness
```

---

## Comparison with Other Libraries

### vs Bloc

```dart
// Bloc
abstract class UserState {}
class UserInitial extends UserState {}
class UserLoading extends UserState {}
class UserLoaded extends UserState {
  final User user;
  UserLoaded(this.user);
}
class UserError extends UserState {
  final String message;
  UserError(this.message);
}

// Qora (sealed, exhaustive, preserves data)
sealed class QoraState<T> {}
class Initial<T> extends QoraState<T> {}
class Loading<T> extends QoraState<T> {
  final T? previousData; // ✅ Keeps stale data
}
class Success<T> extends QoraState<T> {
  final T data;
  final DateTime updatedAt; // ✅ Tracks freshness
}
class Error<T> extends QoraState<T> {
  final Object error;
  final T? previousData; // ✅ Graceful degradation
}
```

### vs Riverpod AsyncValue

```dart
// Riverpod
AsyncValue<User> state;

state.when(
  data: (user) => ...,
  loading: () => ...,
  error: (err, stack) => ...,
);

// Qora (richer state information)
switch (state) {
  case Loading(:final previousData):
    // ✅ Can show stale data during refresh
    if (previousData != null) ...
  
  case Success(:final updatedAt):
    // ✅ Know when data was fetched
    
  case Error(:final previousData):
    // ✅ Graceful error handling
}
```

---

## What's Next?

Now that you understand query states, explore:

- **[QoraClient](./Qora_client.md)**: Master the core client API
- **[Query Keys](./Qora_key.md)**: Deep dive into cache keys
- **[Mutations](./mutations.md)**: Update server state
- **[Optimistic Updates](./optimistic_updates.md)**: Instant UI feedback

---

## Complete Example

```dart [example.dart]
class UserProfilePage extends StatelessWidget {
  final String userId;

  const UserProfilePage({required this.userId});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Profile')),
      body: StreamBuilder<QoraState<User>>(
        stream: context.read<QoraClient>().stream(
          key: ['user', userId],
          fetcher: () => fetchUser(userId),
          refetchInterval: Duration(minutes: 1),
        ),
        builder: (context, snapshot) {
          if (!snapshot.hasData) return Center(child: CircularProgressIndicator());
          
          final state = snapshot.data!;
          
          return RefreshIndicator(
            onRefresh: () async {
              context.read<QoraClient>().invalidate(['user', userId]);
              await snapshot.stream!
                .firstWhere((s) => s is Success || s is Error);
            },
            child: switch (state) {
              Initial() => Center(
                child: ElevatedButton(
                  onPressed: () => context.read<QoraClient>()
                    .invalidate(['user', userId]),
                  child: Text('Load Profile'),
                ),
              ),
              
              Loading(:final previousData) => Stack(
                children: [
                  if (previousData != null)
                    Opacity(
                      opacity: 0.6,
                      child: _buildProfile(previousData),
                    )
                  else
                    Center(child: CircularProgressIndicator()),
                  
                  if (previousData != null)
                    LinearProgressIndicator(),
                ],
              ),
              
              Success(:final data, :final updatedAt) => Column(
                children: [
                  Expanded(child: _buildProfile(data)),
                  _buildFreshness(updatedAt),
                ],
              ),
              
              Error(:final error, :final previousData) => Column(
                children: [
                  if (previousData != null)
                    Expanded(
                      child: Opacity(
                        opacity: 0.7,
                        child: _buildProfile(previousData),
                      ),
                    )
                  else
                    Expanded(
                      child: Center(
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Icon(Icons.error, size: 64, color: Colors.red),
                            SizedBox(height: 16),
                            Text('Failed to load profile'),
                          ],
                        ),
                      ),
                    ),
                  
                  ErrorBanner(
                    error: error,
                    onRetry: () => context.read<QoraClient>()
                      .invalidate(['user', userId]),
                  ),
                ],
              ),
            },
          );
        },
      ),
    );
  }

  Widget _buildProfile(User user) {
    return ListView(
      padding: EdgeInsets.all(16),
      children: [
        CircleAvatar(
          radius: 50,
          backgroundImage: NetworkImage(user.avatarUrl),
        ),
        SizedBox(height: 16),
        Text(
          user.name,
          style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
          textAlign: TextAlign.center,
        ),
        SizedBox(height: 8),
        Text(
          user.email,
          style: TextStyle(fontSize: 16, color: Colors.grey),
          textAlign: TextAlign.center,
        ),
        SizedBox(height: 24),
        Text('Bio', style: TextStyle(fontWeight: FontWeight.bold)),
        SizedBox(height: 8),
        Text(user.bio),
      ],
    );
  }

  Widget _buildFreshness(DateTime updatedAt) {
    final age = DateTime.now().difference(updatedAt);
    String ageText;
    
    if (age.inSeconds < 60) {
      ageText = 'just now';
    } else if (age.inMinutes < 60) {
      ageText = '${age.inMinutes}m ago';
    } else if (age.inHours < 24) {
      ageText = '${age.inHours}h ago';
    } else {
      ageText = '${age.inDays}d ago';
    }
    
    return Container(
      padding: EdgeInsets.all(8),
      color: Colors.grey[200],
      child: Text(
        'Updated $ageText',
        style: TextStyle(fontSize: 12, color: Colors.grey[600]),
        textAlign: TextAlign.center,
      ),
    );
  }
}

class ErrorBanner extends StatelessWidget {
  final Object error;
  final VoidCallback onRetry;

  const ErrorBanner({required this.error, required this.onRetry});

  @override
  Widget build(BuildContext context) {
    return Container(
      color: Colors.red[100],
      padding: EdgeInsets.all(16),
      child: Row(
        children: [
          Icon(Icons.error, color: Colors.red),
          SizedBox(width: 8),
          Expanded(
            child: Text(
              error.toString(),
              style: TextStyle(color: Colors.red[900]),
            ),
          ),
          TextButton(
            onPressed: onRetry,
            child: Text('RETRY'),
          ),
        ],
      ),
    );
  }
}
```

**Ready for more?** Check out [QoraClient Documentation](./Qora_client.md) to see how states integrate with the full caching system.
