---
title: QoraClient
description: The central engine of Qora — manages queries, cache, deduplication, retries, and reactive state.
---

## Constructor

```dart [main.dart]
QoraClient({QoraClientConfig? config})
```

Creates a new client instance. All queries share the same cache and deduplication map.

```dart [main.dart]
// Minimal (all defaults)
final client = QoraClient();

// With full configuration
final client = QoraClient(
  config: QoraClientConfig(
    defaultOptions: QoraOptions(
      staleTime: Duration(minutes: 5),
      retryCount: 2,
    ),
    debugMode: kDebugMode,
    maxCacheSize: 200,
  ),
);
```

---

## Properties

### `config`

```dart
final QoraClientConfig config
```

The resolved configuration for this client instance. Read-only.

### `cachedKeys`

```dart
Iterable<List<dynamic>> get cachedKeys
```

All currently cached query keys (normalised). Useful for debugging or bulk invalidation.

```dart [main.dart]
for (final key in client.cachedKeys) {
  print(key); // [users, 1], [posts], ...
}
```

---

## Fetching

### `fetchQuery`

```dart
Future<T> fetchQuery<T>({
  required Object key,
  required Future<T> Function() fetcher,
  QoraOptions? options,
})
```

Fetch data once and return the result.

**Cache behaviour:**

| Cache state       | Action                                                  |
| ----------------- | ------------------------------------------------------- |
| Fresh (not stale) | Return cached data — no network call                    |
| Stale             | Return stale data immediately; revalidate in background |
| Missing           | Fetch, await, and return result                         |

Concurrent calls with the same key are **deduplicated** — all share a single in-flight request. Failed fetches are retried with exponential backoff up to `retryCount` times.

```dart [user_repository.dart]
final user = await client.fetchQuery<User>(
  key: ['users', userId],
  fetcher: () => api.getUser(userId),
  options: QoraOptions(staleTime: Duration(minutes: 5)),
);
```

**Throws:**

- `StateError` if `QoraOptions.enabled` is `false`
- The fetcher's exception (after all retries) on failure

---

### `watchQuery`

```dart
Stream<QoraState<T>> watchQuery<T>({
  required Object key,
  required Future<T> Function() fetcher,
  QoraOptions? options,
})
```

Create a reactive `Stream<QoraState<T>>` for a query.

**On subscription:**

1. Emits the current cached state immediately
2. Triggers a fetch if data is missing or stale (per `refetchOnMount`)
3. Sets up a polling timer if `refetchInterval` is set
4. Pushes all future state changes — from any source

**On cancel (last subscriber):**

- Cancels the polling timer
- Schedules a GC timer for the cache entry

```dart [user_page.dart]
StreamBuilder<QoraState<User>>(
  stream: client.watchQuery<User>(
    key: ['users', userId],
    fetcher: () => api.getUser(userId),
    options: QoraOptions(refetchInterval: Duration(seconds: 30)),
  ),
  builder: (context, snapshot) {
    return switch (snapshot.data) {
      null || Initial()             => const SizedBox.shrink(),
      Loading(:final previousData)  => previousData != null
          ? UserCard(previousData)
          : const CircularProgressIndicator(),
      Success(:final data)          => UserCard(data),
      Failure(:final error)         => ErrorWidget('$error'),
    };
  },
)
```

---

### `prefetch`

```dart
Future<void> prefetch<T>({
  required Object key,
  required Future<T> Function() fetcher,
  QoraOptions? options,
})
```

Pre-warm the cache without creating a stream. No-op if data is already fresh.

```dart [user_list_page.dart]
onEnter: (_) => client.prefetch<User>(
  key: ['users', userId],
  fetcher: () => api.getUser(userId),
),
```

---

## Cache Reads

### `getQueryData`

```dart
T? getQueryData<T>(Object key)
```

Returns the best available data for `key`, or `null`. Returns `Success.data`, or `previousData` from `Loading`/`Failure`.

```dart [main.dart]
final user = client.getQueryData<User>(['users', userId]);
```

---

### `getQueryState`

```dart
QoraState<T> getQueryState<T>(Object key)
```

Returns the full `QoraState<T>`, or `Initial<T>()` if not cached.

```dart [main.dart]
final state = client.getQueryState<User>(['users', userId]);
if (state is Success<User>) {
  print('Age: ${state.age}');
}
```

---

## Cache Writes

### `setQueryData`

```dart
void setQueryData<T>(Object key, T data)
```

Inject data directly into the cache. Instantly pushes `Success` to all active `watchQuery` streams.

```dart [main.dart]
client.setQueryData(['users', userId], updatedUser);
```

---

### `restoreQueryData`

```dart
void restoreQueryData<T>(Object key, T? snapshot)
```

Roll back to a previous snapshot. If `snapshot` is `null`, the entry is removed from cache.

```dart [main.dart]
final snapshot = client.getQueryData<User>(['users', userId]);
client.setQueryData(['users', userId], optimisticUser);

try {
  await api.updateUser(userId, payload);
} catch (_) {
  client.restoreQueryData(['users', userId], snapshot);
}
```

---

## Invalidation

### `invalidate`

```dart
void invalidate(Object key)
```

Mark a query as stale. Active `watchQuery` streams receive `Loading(previousData: ...)` immediately. The next access triggers a fresh fetch.

```dart [main.dart]
await api.createPost(payload);
client.invalidate(['posts']);
```

---

### `invalidateWhere`

```dart
void invalidateWhere(bool Function(List<dynamic> key) predicate)
```

Invalidate all queries whose key satisfies `predicate`.

```dart [main.dart]
// All user queries
client.invalidateWhere((key) => key.firstOrNull == 'users');

// Specific user + their sub-resources
client.invalidateWhere(
  (key) => key.length >= 2 && key[0] == 'users' && key[1] == userId,
);
```

---

## Cache Removal

### `removeQuery`

```dart
void removeQuery(Object key)
```

Remove an entry from cache and cancel any pending request. The next access starts from `Initial`.

```dart [main.dart]
await api.deletePost(postId);
client.removeQuery(['posts', postId]);
```

---

### `clear`

```dart
void clear()
```

Wipe the entire cache and cancel all pending requests.

```dart [main.dart]
// On logout
client.clear();
```

---

## Debugging

### `debugInfo`

```dart
Map<String, dynamic> debugInfo()
```

Returns a debug snapshot of the current cache state.

```dart [main.dart]
print(client.debugInfo());
// {
//   total_queries: 12,
//   active_queries: 3,
//   inactive_queries: 9,
//   pending_requests: 1,
//   max_size: 200,
//   keys: [['users', 1], ['posts'], ...]
// }
```

---

## Lifecycle

### `dispose`

```dart
void dispose()
```

Release all resources. Stops the eviction timer, disposes all cache entries, cancels pending requests. The client **must not** be used after this call.

```dart [main.dart]
// In a DI teardown or test tearDown
client.dispose();
```

---

## Recommended Setup

```dart [lib/core/qora.dart]
import 'package:flutter/foundation.dart';
import 'package:qora/qora.dart';

/// Singleton — create once, inject everywhere via DI or QoraScope.
final qoraClient = QoraClient(
  config: QoraClientConfig(
    defaultOptions: QoraOptions(
      staleTime: Duration(minutes: 5),
      cacheTime: Duration(minutes: 10),
      retryCount: 3,
    ),
    debugMode: kDebugMode,
    maxCacheSize: 200,
    refetchOnMount: true,
    errorMapper: (error, stack) => QoraException(
      '$error',
      originalError: error,
      stackTrace: stack,
    ),
  ),
);
```
