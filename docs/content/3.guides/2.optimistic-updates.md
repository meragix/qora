---
title: Optimistic Updates
description: Update the UI instantly while mutations are in flight, and roll back safely on failure — with no extra libraries.
---

An **optimistic update** reflects a mutation in the UI immediately, before the server has confirmed it. If the request fails, you roll back to the previous state. The result is a fast, responsive experience even on slow connections.

Qora provides three primitives that make this pattern straightforward:

| Method                                        | Description                                                                 |
| --------------------------------------------- | --------------------------------------------------------------------------- |
| `client.getState<T>(key)`                     | Snapshot the current state (includes data and metadata)                     |
| `client.setQueryData<T>(key, data)`           | Push data directly into the cache — all subscribed widgets update instantly |
| `client.restoreQueryData<T>(key, snapshot)`   | Restore a previously snapshotted state                                      |

---

## The Pattern

```dart [update_user.dart]
Future<void> updateUserName(BuildContext context, int userId, String newName) async {
  final client = context.qora;
  final key = ['users', userId];

  // 1. Snapshot the current state for rollback
  final snapshot = client.getState<User>(key);
  final previousUser = snapshot.dataOrNull;

  try {
    // 2. Apply the optimistic update — UI reflects the change instantly
    if (previousUser != null) {
      client.setQueryData<User>(key, previousUser.copyWith(name: newName));
    }

    // 3. Fire the mutation
    final updatedUser = await UserApi.updateUser(userId, newName);

    // 4. Confirm with the authoritative server response
    client.setQueryData<User>(key, updatedUser);

    // 5. Invalidate related queries (e.g. the list that shows the name)
    client.invalidateWhere((key) => key.firstOrNull == 'users');
  } catch (error) {
    // 6. Rollback to the pre-mutation state
    client.restoreQueryData<User>(key, snapshot);

    if (context.mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to update: $error')),
      );
    }
  }
}
```

### Step-by-step

| Step | Call                                 | Effect                                                          |
| ---- | ------------------------------------ | --------------------------------------------------------------- |
| 1    | `getState(key)`                     | Captures the current `QoraState` (data + timestamps)            |
| 2    | `setQueryData(key, optimisticData)`  | Cache updated → all active `QoraBuilder` widgets rebuild        |
| 3    | `UserApi.updateUser(...)`            | Network request in flight                                       |
| 4    | `setQueryData(key, serverData)`      | Cache confirmed with authoritative data from the server         |
| 5    | `invalidateWhere(...)`               | Related queries (e.g. the user list) will refetch               |
| 6    | `restoreQueryData(key, snapshot)`    | Cache reverted → UI snaps back to the pre-mutation state        |

---

## Full Example: Edit Profile Screen

```dart [screens/edit_profile_screen.dart]
class EditProfileScreen extends StatefulWidget {
  final int userId;

  const EditProfileScreen({super.key, required this.userId});

  @override
  State<EditProfileScreen> createState() => _EditProfileScreenState();
}

class _EditProfileScreenState extends State<EditProfileScreen> {
  late final TextEditingController _nameController;
  bool _isSaving = false;

  @override
  void initState() {
    super.initState();
    final currentUser = context.qora
        .getState<User>(['users', widget.userId])
        .dataOrNull;
    _nameController = TextEditingController(text: currentUser?.name ?? '');
  }

  @override
  void dispose() {
    _nameController.dispose();
    super.dispose();
  }

  Future<void> _save() async {
    if (_isSaving) return;
    setState(() => _isSaving = true);

    final client = context.qora;
    final key = ['users', widget.userId];
    final snapshot = client.getState<User>(key);
    final previousUser = snapshot.dataOrNull;

    try {
      // Optimistic update
      if (previousUser != null) {
        client.setQueryData<User>(
          key,
          previousUser.copyWith(name: _nameController.text),
        );
      }

      final updated = await UserApi.updateUser(
        widget.userId,
        _nameController.text,
      );

      client.setQueryData<User>(key, updated);
      client.invalidateWhere((k) => k.firstOrNull == 'users');

      if (mounted) Navigator.pop(context);
    } catch (error) {
      client.restoreQueryData<User>(key, snapshot);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Save failed: $error')),
        );
        setState(() => _isSaving = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Edit Profile'),
        actions: [
          TextButton(
            onPressed: _isSaving ? null : _save,
            child: _isSaving
                ? const SizedBox(
                    width: 16,
                    height: 16,
                    child: CircularProgressIndicator(strokeWidth: 2),
                  )
                : const Text('Save'),
          ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: TextField(
          controller: _nameController,
          decoration: const InputDecoration(labelText: 'Name'),
        ),
      ),
    );
  }
}
```

When the user taps **Save**:

1. The `UserDetailScreen` (which uses `QoraBuilder<User>`) immediately reflects the new name — no spinner, no delay.
2. The network request fires in the background.
3. If it succeeds, the server response confirms the data.
4. If it fails, the name reverts to what it was before the tap.

---

## Invalidating Related Queries

After a successful mutation you typically want to invalidate related queries so stale list views refresh. Use `invalidateWhere` with a predicate:

```dart [update_user.dart]
// Invalidate the specific user AND the users list
client.invalidateWhere((key) => key.firstOrNull == 'users');

// More targeted: only the list, not the individual entry
client.invalidateWhere((key) => key.length == 1 && key.firstOrNull == 'users');

// Or invalidate the exact key
client.invalidate(['users']);
```

Active `QoraBuilder` widgets for any matching key receive `Loading(previousData: data)` and immediately re-fetch. Because the previous data is carried through, there is no flash of empty content.

---

## Why `restoreQueryData` Instead of `setQueryData`?

`restoreQueryData` accepts a full `QoraState<T>` snapshot, not just the data value. This means the `updatedAt` timestamp, state type (`Success`, `Initial`, etc.), and any `previousData` are all restored exactly as they were. Using `setQueryData` for rollback would always produce a `Success` state — even if the original state was `Initial` or `Loading`.

```dart [rollback.dart]
// ✅ Correct — restores exact state including timestamp and state type
client.restoreQueryData<User>(key, snapshot);

// ❌ Incorrect — always produces Success, loses original state metadata
if (previousUser != null) {
  client.setQueryData<User>(key, previousUser);
}
```

---

## Best Practices

### ✅ Do

```dart [update.dart]
// Always snapshot before mutating
final snapshot = client.getState<User>(key);

// Apply optimistic update only when data exists
if (snapshot.dataOrNull != null) {
  client.setQueryData(key, optimisticData);
}

// Always restore on any error path
} catch (_) {
  client.restoreQueryData(key, snapshot);
}
```

### ❌ Don't

```dart [update.dart]
// Don't skip the snapshot — you won't be able to roll back
client.setQueryData(key, optimisticData);
await api.update(data); // if this throws, no rollback possible

// Don't ignore the error — always inform the user
} catch (_) {} // ❌ Silent failure is worse than no optimistic update
```

---

## Next Steps

- [Basic Usage](./basic-usage.md) — List and detail screens without mutations
- [QoraClient API](../api-reference/qora-client.md) — `setQueryData`, `getState`, `restoreQueryData` reference
- [Query States](../core-concepts/query-states.md) — Understanding the state machine that makes rollback predictable
