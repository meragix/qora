---
title: Mutations
description: Perform write operations (POST, PUT, DELETE) with full lifecycle support — optimistic updates, automatic rollback, retry, and DevTools observability.
seo:
  title: Mutations — Qora
  description: Perform write operations with MutationController. Full lifecycle support with optimistic updates, automatic rollback, retry, and DevTools observability.
---

A **mutation** is any operation that changes server-side state: creating a resource, updating a field, deleting a record. Unlike queries (which are read-only and cached), mutations are fire-and-forget writes that you trigger explicitly.

Qora manages mutations with `MutationController` — a standalone lifecycle controller that has no cache key, no deduplication, and no SWR. It simply tracks the state of a single in-progress write.

---

## The State Machine

```text
MutationIdle
    │
    │  mutate(variables)
    ▼
MutationPending
    │
    ├── success ──▶ MutationSuccess
    │
    └── failure ──▶ MutationFailure
            │
            └── reset() ──▶ MutationIdle
```

Every state carries `variables` — the value that was passed to `mutate()`. This makes it easy to display "Creating post…" or "Failed to delete comment #42" without extra local state.

---

## Basic Usage

```dart [post_repository.dart]
final controller = MutationController<Post, String, void>(
  mutator: (title) => api.createPost(title),
);

// Trigger the mutation
final post = await controller.mutate('Hello, Qora!');
// Returns the Post on success, or null on failure.

// Observe state transitions
controller.stream.listen((state) {
  switch (state) {
    case MutationIdle():
      print('Ready');
    case MutationPending(:final variables):
      print('Creating "$variables"…');
    case MutationSuccess(:final data):
      print('Created: ${data.title}');
    case MutationFailure(:final error):
      print('Failed: $error');
  }
});

// Reset to idle after showing the result
controller.reset();

// Always dispose when done
controller.dispose();
```

`mutate()` never throws. Errors are captured in `MutationFailure` state and returned as `null` from the call site.

---

## Lifecycle Callbacks

`MutationOptions` provides four hooks that run around the mutation:

```dart [post_repository.dart]
final controller = MutationController<Post, String, void>(
  mutator: (title) => api.createPost(title),
  options: MutationOptions(
    onMutate: (title) async {
      print('About to create "$title"');
      // Return value becomes TContext — passed to onSuccess, onError, onSettled.
    },
    onSuccess: (post, title, _) async {
      print('Created: ${post.id}');
      client.invalidate(['posts']); // Refresh the posts list
    },
    onError: (error, title, _) async {
      print('Failed to create "$title": $error');
    },
    onSettled: (post, error, title, _) async {
      // Called regardless of outcome.
      analytics.track('post_create_attempt', {'success': error == null});
    },
  ),
);
```

| Hook                                             | When                          | Receives                                           |
| ------------------------------------------------ | ----------------------------- | -------------------------------------------------- |
| `onMutate(variables)`                            | Before the mutator starts     | `TVariables`                                       |
| `onSuccess(data, variables, context)`            | After a successful mutator    | `TData`, `TVariables`, `TContext?`                 |
| `onError(error, variables, context)`             | After the mutator throws      | `Object`, `TVariables`, `TContext?`                |
| `onSettled(data, error, variables, context)`     | After either outcome          | `TData?`, `Object?`, `TVariables`, `TContext?`     |

The value returned by `onMutate` becomes `TContext` — the third type parameter of `MutationController`. This is the mechanism behind optimistic update rollback.

---

## Optimistic Updates

Optimistic updates apply a change to the local cache immediately — before the server confirms it. If the server rejects the change, the previous data is restored.

The pattern has three steps:

1. **`onMutate`** — snapshot the current cache data, apply the optimistic change, return the snapshot as `TContext`
2. **`onError`** — use the snapshot (`TContext`) to roll back via `client.restoreQueryData()`
3. **`onSuccess`** — invalidate the query to pull the confirmed server data

```dart [post_repository.dart]
final controller = MutationController<Post, String, List<Post>?>(
  // TContext = List<Post>? — the snapshot we'll use for rollback
  mutator: (title) => api.createPost(title),
  options: MutationOptions(
    onMutate: (title) async {
      // 1️⃣ Snapshot
      final previous = client.getQueryData<List<Post>>(['posts']);

      // 2️⃣ Optimistic update — UI reflects change immediately
      client.setQueryData<List<Post>>(
        ['posts'],
        [...?previous, Post.optimistic(title)],
      );

      return previous; // Becomes TContext
    },
    onError: (error, title, previous) async {
      // 3️⃣ Rollback — restore the snapshot on failure
      client.restoreQueryData(['posts'], previous);
    },
    onSuccess: (post, title, _) async {
      // 4️⃣ Confirm — replace optimistic data with real server data
      client.invalidate(['posts']);
    },
  ),
);

await controller.mutate('New Post');
```

:::tip
`client.restoreQueryData(key, null)` removes the query from the cache entirely — useful when the snapshot was `null` (the list didn't exist yet).
:::

---

## Handling `onMutate` Failure

If `onMutate` throws (e.g. a pre-flight validation fails), the mutator is **not called**. The controller transitions directly to `MutationFailure`.

```dart [post_repository.dart]
options: MutationOptions(
  onMutate: (title) async {
    if (title.isEmpty) throw ArgumentError('Title cannot be empty');
    // Mutator will never run if this throws
    return null;
  },
),
```

This is useful for client-side validation that should block the network call entirely.

---

## Retry

By default mutations do not retry (unlike queries, retrying a write can have side effects). Enable retry explicitly:

```dart [post_repository.dart]
options: const MutationOptions(
  retryCount: 2,                       // 1 initial + 2 retries = 3 total attempts
  retryDelay: Duration(seconds: 1),    // Exponential backoff: 1s, 2s
),
```

Retry only applies to the mutator. If `onMutate` throws, no retry occurs.

---

## Standalone Mode

`MutationController` works without any `QoraClient`. Pass `tracker: null` (the default) to operate in standalone mode with no global observability:

```dart [checkout_service.dart]
// No client required — mutations work anywhere
final controller = MutationController<Order, Cart, void>(
  mutator: (cart) => paymentApi.checkout(cart),
);
```

---

## DevTools Observability

Wire a controller into `QoraClient` by passing `tracker: client`. The client then exposes all mutation activity via `mutationEvents` and `activeMutations`.

```dart [post_repository.dart]
final controller = MutationController<Post, String, void>(
  mutator: (title) => api.createPost(title),
  tracker: client,

  // Optional: label this controller for DevTools filtering
  metadata: {'category': 'content', 'resource': 'post'},
);

// Listen to all mutation activity across all tracked controllers
client.mutationEvents.listen((event) {
  if (event.isError) {
    logger.error('[${event.mutatorId}] Failed', event.error);
  }
});

// Snapshot of currently running mutations (only Pending entries)
final running = client.activeMutations;
print('${running.length} mutation(s) in flight');
```

:::tip
`activeMutations` only contains `MutationPending` entries — finished mutations (Success or Failure) are auto-purged. This prevents memory accumulation and makes the map a reliable "currently in-flight" indicator.
:::

When using `MutationBuilder` in Flutter, `tracker` is set to `QoraScope.maybeOf(context)` automatically — no manual wiring needed.

---

## Multi-Query Optimistic Updates

A single mutation can touch multiple queries. Each `setQueryData` call triggers a reactive update in any `QoraBuilder` subscribed to that key:

```dart [post_repository.dart]
options: MutationOptions(
  onMutate: (postId) async {
    // Snapshot both queries
    final posts = client.getQueryData<List<Post>>(['posts']);
    final user = client.getQueryData<User>(['users', currentUserId]);

    // Update both optimistically
    client.setQueryData<List<Post>>(
      ['posts'],
      posts?.where((p) => p.id != postId).toList(),
    );
    client.setQueryData<User>(
      ['users', currentUserId],
      user?.copyWith(postCount: (user.postCount ?? 1) - 1),
    );

    return (posts: posts, user: user); // TContext is a record
  },
  onError: (error, postId, snapshots) async {
    // Roll back both
    client.restoreQueryData(['posts'], snapshots?.posts);
    client.restoreQueryData(['users', currentUserId], snapshots?.user);
  },
),
```

---

## Next Steps

- [MutationBuilder](../flutter-integration/qora-mutation-builder.md) — Bind mutations to Flutter UI
- [Optimistic Updates](./optimistic-updates.md) — Deep dive into rollback patterns
- [Mutation API Reference](../api-reference/qora-mutation.md) — Full API documentation
